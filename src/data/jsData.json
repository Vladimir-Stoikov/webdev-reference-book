{
  "jsLessons": [
    {"id": 1, "header": "Что такое", "content": "JavaScript — это кросс-платформенный, объектно-ориентированный скриптовый язык, являющийся небольшим и легковесным. Внутри среды исполнения JavaScript может быть связан с объектами данной среды и предоставлять программный контроль над ними. \n\n    JavaScript включает стандартную библиотеку объектов, например, Array, Date и Math, а также базовый набор языковых элементов, например, операторы и управляющие конструкции. Ядро JavaScript может быть расширено для различных целей путём добавления в него новых объектов, например: JavaScript на стороне клиента расширяет ядро языка, предоставляя объекты для контроля браузера и его Document Object Model (DOM). Например, клиентские расширения позволяют приложению размещать элементы в форме HTML и обрабатывать пользовательские события, такие как щелчок мыши, ввод данных в форму и навигация по страницам. JavaScript на стороне сервера расширяет ядро языка, предоставляя объекты для запуска JavaScript на сервере. Например, расширение на стороне сервера позволяет приложению соединяться с базой данных, обеспечивать непрерывность информации между вызовами приложения или выполнять манипуляции над файлами на сервере."},
    {"id": 2, "header": "Грамматика и типы", "content": "JavaScript чувствителен к регистру и использует кодировку символов Unicode. Например, слово Früh (\"рано\" по-немецки) может использоваться в качестве имени переменной. \n\n    В JavaScript инструкции называются statements и разделяются точкой с запятой (;). Пробел (space), табуляция (tab) и перевод строки (newline) называются пробельными символами (whitespace). Исходный текст скриптов на JavaScript сканируется слева направо и конвертируется в последовательность входных элементов, являющихся токенами (tokens), управляющими символами, символами конца строки, комментариями или пробельными символами. \n\n    ECMAScript также определяет некоторые ключевые слова и литералы и устанавливает правила для автоматической вставки точек с запятой (ASI), чтобы обозначить конец инструкций (statements). Однако, рекомендуется всегда ставить точку с запятой в конце каждой инструкции вручную, чтобы избежать побочных эффектов. Чтобы получить более подробную информацию, прочитайте Lexical Grammar."}
  ],
  "tsLessons": [
    {"id": 1, "header": "Переменные", "content": "  <span>Типизация numbers</span> \n\n   let x = 10;\n   let y = 5.5;\n   let z = NaN;\n\n <span>Типизация BigInt</span> \n\n   let bigX = 1321n; \n\n <span>Типизация string</span> \n\n  let str1 = \"boop\";\n  let str2: string;\n  str2 = \"hi\";\n\n  <span>Типизация symbol</span> \n\n  let symb = Symbol('as');\n\n <span>Типизация boolean</span> \n\n   let compare = true;\n   compare = false\n\n  <span>Типизация undefined</span> <i>(надо задавать самому, если не прописано в компиляторе)</i>\n\n  const missed: undefined = undefined;\n\n <span>Типизация null</span> <i>(надо задавать самому, если не прописано в компиляторе)</i> \n\n  const empty: null = null;\n\n <span>Типизация literal</span> <i>(конкретное значение, которое не может претерпевать изменений. Задается константой)</i>\n\n   const litNum = 777;\n   const litStr = 'lucky';\n\n <span>Отдельный тип any</span> <i>(Тип для крайнего случая как временная затычка, которую нужно в будущем править. Не дает подсказок после точки)</i>\n\n   let universal: any = 1;\n   universal = 'str';\n   universal = [];\n\n <span>Отдельный тип unknow</span> <i>(Используется когда тип переменной будет определяться в будущем. Не дает такой же свободы как и any, например требует проверки типа через условие)</i>\n\n   let unknown: unknown = \"lowercase\";\n   if(typeof unknown === \"string\") unknown.toUpperCase();"},
    {"id": 2, "header": "Функции", "content": "<span>Базовый синтаксис.</span>\n\nfunction sum(a: number, b: number): number {\n  return a + b;\n}\n\n <i>Параметры функции типизировать обязательно, возвращаемое значение обычно определяется правильно.</i> \n\n<span>Необычные возвращаемые типы</span>\n\nfunction log(name: string, userId?: string): void {\n  console.log(\"Log \", name, \" User Id is \", userId || \"none\");\n}\n\n <i>Тип \"void\" для возвращаемого значения функции обозначет, что она ничего не вернет, но завершится.\n Значек \"?\" после параметра функции показывает что он необязателен. \n Аргумент будет принимать и значения указанного типа и undefined.</i>\n\nfunction crash(): never {\n  throw new Error(\"crash\");\n}\n\n <i>Использование типа \"never\" указывает на то, что функция не будет завершена.</i>\n\n <span>Типизация параметра массива</span>\n\nfunction average(...nums: number[]): number {\n  const sum = nums.reduce((total, current) => total + current, 0);\n  return sum / nums.length;\n}\n\n <span>Примеры со стрелочной функций и функциональным выражением</span>\n\nconst sum2 = (a: number, b: number): number => {\n  return a + b;\n}\n\nconst sum3 = function (a: number, b: number): number {\n  return a + b;\n}\n\n <span>Упражнение</span>\n\nfunction slice(str: string, start: number, end?: number): string {\n  let newStr = '';\n\n  let lastIndex: number;\n\n  if(end) {\n    lastIndex = end > str.length ? str.length : end;\n  } else {\n    lastIndex = str.length;\n  }\n\n  for (let i = start; i < lastIndex; i++) {\n    newStr += str[i];    \n  }\n\n  return newStr;\n}"},
    {"id": 3, "header": "Объекты", "content": "<span>Простейший способ записи типа объекта</span>\n\nconst carSimple: {\n  wheels: number,\n  brand: string,\n  type: string,\n} = {\n  wheels: 4,\n  brand: 'BMW',\n  type: 'Sedan',\n}\n\n<span>Использование interface для возможности переиспользовать тип с другим объектом</span>\n\ninterface Car {\n  wheels: number,\n  brand: string,\n  type: string,\n  isNew?: boolean, *\n  name?: string, **\n  [key: string]: unknown ***\n}\n\n<i>* Также как и в параметрах функции можно делать опциональные свойства для объекта. \n** Обычно опциональные свойства записывают после обязательных\n*** Данная запись позволяет добавлять дополнительные свойства для объекта</i>\n\nconst car: Car = {\n  wheels: 4,\n  brand: 'BMW',\n  type: 'Sedan',\n}\n\nconst car2: Car = {\n  wheels: 4,\n  brand: 'BMW',\n  type: 'Sedan',\n}\n\n\n<i>[key: string]: unknown - из-за данной строчки это будет работать\n\ncar2.go = true  \n\nВ популярном style гайде записывание допольнительных свойств происходит через скобки\n\ncar2['go2'] = true</i>"},
    {"id": 4, "header": "Объекты как параметры функции", "content": "<span>Когда мы используем объекты в качестве параметров функции, при типизации мы указываем минимальный набор параметров, которые нужны для работы функции. Сами объекты могут быть разными, главное, чтобы в них был указанный минимум</span>\n\nfunction printPoint(point: {x: string, y: string}): void {\n  console.log(`Point coord is x: ${point.x} and y: ${point.y}`);\n}\n\n<i>Работает и полностью соответствует типизации параметров функции</i>\n\nconst obj1 = {\n  x: '1',\n  y: '2'\n}\n\nprintPoint(obj1);\n\n<i>Тоже работает, так как имеет минимальный набор свойств, соответствующих типизации параметров функции</i>\n\nconst obj2 = {\n  x: '1',\n  y: '2'\n}\n\nprintPoint(obj2);\n\n<span>Также в функции могут быть и опциональные параметры,</span> <i>но чтобы функция работала корректно необходимо проверять их наличие через if, иначе из-за попытки вызова undefined аргумента мы получим ошибку</i> \n\nfunction printName(user: {firstName: string, lastName?: string}): void {\n  console.log(`Hello ${user.firstName.toUpperCase()}`);\n\n  if(user.lastName) {\n      console.log(`Nice to meet you mr/mis ${user.lastName.toUpperCase()}`);\n  }\n}\n\nprintName({firstName: 'Vladimir'});\nprintName({firstName: 'Vladimir', lastName: 'St'});"},
    {"id": 5, "header": "Массивы", "content": "<span>Типизация массивов</span>\n\nЧаще всего объекты массива имеют один конкретный тип данных\n\nconst numbers = [1,2,3,4];\n\n<i>TS автоматически определит что это массив чисел numbers[]</i>\n\nПри этом если дописывать новые типы, то он автоматически добавит и их\n(numbers|string|boolean)[]\n\nconst numbersAndOther = [1,2,3,4,'five', true];\n\n<i>При создании пустого массива надо явно указывать тип\nиначе будет any[]</i>\n\nconst arrStr: string[] = [];\n\nМенее частый вариант указания типа массива\n\nconst arrStr2: Array<string> = [];\n\nTS выдаст ошибку \n\narrStr.push(1);\n\n<span>Массивы также можно типизировать и объектами</span>\n\ninterface arrCar {\n  wheels: number;\n  brand: string;\n}\n\nconst cars: arrCar[] = [];\ncars.push({wheels: 4, brand: 'Audi'});\n\n<span>Типизация вложенного массива</span>\n\nconst arrOfArr: string[][] = [];\narrOfArr.push(['one', 'two']);\n\n<span>Использование в параметрах функции</span>\n\nfunction printArr(arr: unknown[]): void {\n  arr.forEach((el, index, array) => {\n    console.log(el, index, array);\n  })\n}\n\n<i>В данном случае el из arr.forEach автоматически подтянет свой тип\nиз arr:unknown[] в параметрах функции</i>"},
    {"id": 6, "header": "Кортежи(tuples)", "content": "<span>Типизация кортежей (tuples)</span>\n\nconst pairs: [string, string][] = [['key', 'value'], ['key2', 'value2']];\n\n<i>Пример использования, хранение табличных данных</i>\n\nconst doc: [string, string, number, Date][] = [];\ndoc.push(['Vladimir', 'St', 30, new Date()]);"},
    {"id": 7, "header": "Псевдонимы типов (Type Aliases)", "content": "<span>Псевдонимы типов (Type Aliases)</span>\n\n<i>Позволяет создавать свои типы данных, схожи с интерфейсами, но гибче</i>\n\ntype MyBoolean = false | true;\ntype Pair = [string, string];\ntype Pairs = Pair[];\n\n<i>Можно использовать и для типизации объекта</i>\n\ntype TypedCar = {\n  wheels: number,\n  brand: string,\n  type: string,\n  isNew?: MyBoolean,\n  name?: string,\n  [key: string]: unknown\n}"}
  ]
}