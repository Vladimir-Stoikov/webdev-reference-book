{
  "jsLessons": [
    {"id": 1, "header": "Что такое", "content": "<span>Что такое JavaScript</span>\n\n  JavaScript — это кросс-платформенный, объектно-ориентированный скриптовый язык, являющийся небольшим и легковесным. Внутри среды исполнения JavaScript может быть связан с объектами данной среды и предоставлять программный контроль над ними. \n\n  <span>Содержимое</span> \n\n JavaScript включает стандартную библиотеку объектов, например, Array, Date и Math, а также базовый набор языковых элементов, например, операторы и управляющие конструкции. Ядро JavaScript может быть расширено для различных целей путём добавления в него новых объектов, например: JavaScript на стороне клиента расширяет ядро языка, предоставляя объекты для контроля браузера и его Document Object Model (DOM). Например, клиентские расширения позволяют приложению размещать элементы в форме HTML и обрабатывать пользовательские события, такие как щелчок мыши, ввод данных в форму и навигация по страницам. JavaScript на стороне сервера расширяет ядро языка, предоставляя объекты для запуска JavaScript на сервере. Например, расширение на стороне сервера позволяет приложению соединяться с базой данных, обеспечивать непрерывность информации между вызовами приложения или выполнять манипуляции над файлами на сервере."},
    {"id": 2, "header": "Грамматика и типы", "content": "<span>Основы</span> \n\n JavaScript чувствителен к регистру и использует кодировку символов Unicode. Например, слово Früh (\"рано\" по-немецки) может использоваться в качестве имени переменной. \n\n    В JavaScript инструкции называются statements и разделяются точкой с запятой (;). Пробел (space), табуляция (tab) и перевод строки (newline) называются пробельными символами (whitespace). Исходный текст скриптов на JavaScript сканируется слева направо и конвертируется в последовательность входных элементов, являющихся токенами (tokens), управляющими символами, символами конца строки, комментариями или пробельными символами. \n\n    ECMAScript также определяет некоторые ключевые слова и литералы и устанавливает правила для автоматической вставки точек с запятой (ASI), чтобы обозначить конец инструкций (statements). Однако, рекомендуется всегда ставить точку с запятой в конце каждой инструкции вручную, чтобы избежать побочных эффектов. Чтобы получить более подробную информацию, прочитайте Lexical Grammar."},
    {"id": 3, "header": "Объявления", "content": "<span>В JavaScript существует три вида объявлений</span> \n\n <i>var</i> \n\n Объявляет переменную, инициализация переменной значением является необязательной. \n\n <i>let</i> \n\n Объявляет локальную переменную в области видимости блока, инициализация переменной значением является необязательной.\n\n  <i>const</i> \n\n  Объявляет именованную константу, доступную только для чтения.\n\n <span>Переменные</span> \n\n  Вы можете использовать переменные как символические имена для значений в вашем приложении. Имена переменных называются <i>identifiers</i> и должны соответствовать определённым правилам.\n\n  Идентификатор в JavaScript должен начинаться с буквы, нижнего подчёркивания (_) или знака доллара ($); последующие символы могут также быть цифрами (0-9). Поскольку JavaScript чувствителен к регистру, буквы включают символы от \"A\" до \"Z\" (верхний регистр) и символы от \"a\" до \"z\" (нижний регистр). \n\n Вы можете использовать в идентификаторах буквы ISO 8859-1 или Unicode, например, å или ü. Вы также можете использовать управляющие последовательности Unicode как символы в идентификаторах. Некоторые примеры корректных имён: Number_hits, temp99, _name.\n\n <span>Объявление переменных</span>\n\n Вы можете объявить переменную тремя способами:\n\n <i>Используя ключевое слово var</i>. Например, var x = 42. Данный синтаксис может быть использован для объявления как локальных, так и глобальных переменных.\n\n <i>Просто присвоить переменной значение</i>. Например, x = 42. Переменные, объявленные данным способом, являются глобальными. Такое объявление генерирует строгое предупреждение (strict mode). Не рекомендуется использовать данный способ.\n\n <i>Используя ключевое слово let</i>. Например, let y = 13. Данный синтаксис может быть использован для объявления локальной переменной в области видимости блока."},
    {"id": 4, "header": "Присваивание значений", "content": "<span>Присваивание значений</span>\n\n Переменная, объявленная через var или let без присвоения начального значения, имеет значение undefined.\n\n При попытке доступа к необъявленной переменной или переменной до её объявления будет выброшено исключение ReferenceError:\n\n var a;\nconsole.log(\"The value of a is \" + a); //Значение переменной a undefined\n\nconsole.log(\"The value of b is \" + b); //Uncaught ReferenceError: b не определена\n\nconsole.log(\"The value of c is \" + c); //Значение переменной c undefined\nvar c;\n\nconsole.log(\"The value of x is \" + x); //Uncaught ReferenceError: x не определена\nlet x;\n\n <i>Вы можете использовать undefined, чтобы определить, имеет ли переменная значение.</i> В следующем примере переменной input не присвоено значение, и оператор if будет вычислен как true:\n\n var input;\nif (input === undefined) {\n  doThis();\n} else {\n  doThat();\n}\n\n Значение undefined ведёт себя как false, когда используется в <i>логическом контексте,</i> а также конвертируется в NaN, когда используется в <i>числовом контексте.</i>\n\n Значение <i>null</i> ведёт себя как 0 в числовом контексте и как false в логическом контексте."}
  ],
  "tsLessons": [
    {"id": 1, "header": "Переменные", "content": "  <span>Типизация numbers</span> \n\n   let x = 10;\n   let y = 5.5;\n   let z = NaN;\n\n <span>Типизация BigInt</span> \n\n   let bigX = 1321n; \n\n <span>Типизация string</span> \n\n  let str1 = \"boop\";\n  let str2: string;\n  str2 = \"hi\";\n\n  <span>Типизация symbol</span> \n\n  let symb = Symbol('as');\n\n <span>Типизация boolean</span> \n\n   let compare = true;\n   compare = false\n\n  <span>Типизация undefined</span> <i>(надо задавать самому, если не прописано в компиляторе)</i>\n\n  const missed: undefined = undefined;\n\n <span>Типизация null</span> <i>(надо задавать самому, если не прописано в компиляторе)</i> \n\n  const empty: null = null;\n\n <span>Типизация literal</span> <i>(конкретное значение, которое не может претерпевать изменений. Задается константой)</i>\n\n   const litNum = 777;\n   const litStr = 'lucky';\n\n <span>Отдельный тип any</span> <i>(Тип для крайнего случая как временная затычка, которую нужно в будущем править. Не дает подсказок после точки)</i>\n\n   let universal: any = 1;\n   universal = 'str';\n   universal = [];\n\n <span>Отдельный тип unknow</span> <i>(Используется когда тип переменной будет определяться в будущем. Не дает такой же свободы как и any, например требует проверки типа через условие)</i>\n\n   let unknown: unknown = \"lowercase\";\n   if(typeof unknown === \"string\") unknown.toUpperCase();"},
    {"id": 2, "header": "Функции", "content": "<span>Базовый синтаксис.</span>\n\nfunction sum(a: number, b: number): number {\n  return a + b;\n}\n\n <i>Параметры функции типизировать обязательно, возвращаемое значение обычно определяется правильно.</i> \n\n<span>Необычные возвращаемые типы</span>\n\nfunction log(name: string, userId?: string): void {\n  console.log(\"Log \", name, \" User Id is \", userId || \"none\");\n}\n\n <i>Тип \"void\" для возвращаемого значения функции обозначет, что она ничего не вернет, но завершится.\n Значек \"?\" после параметра функции показывает что он необязателен. \n Аргумент будет принимать и значения указанного типа и undefined.</i>\n\nfunction crash(): never {\n  throw new Error(\"crash\");\n}\n\n <i>Использование типа \"never\" указывает на то, что функция не будет завершена.</i>\n\n <span>Типизация параметра массива</span>\n\nfunction average(...nums: number[]): number {\n  const sum = nums.reduce((total, current) => total + current, 0);\n  return sum / nums.length;\n}\n\n <span>Примеры со стрелочной функций и функциональным выражением</span>\n\nconst sum2 = (a: number, b: number): number => {\n  return a + b;\n}\n\nconst sum3 = function (a: number, b: number): number {\n  return a + b;\n}\n\n <span>Упражнение</span>\n\nfunction slice(str: string, start: number, end?: number): string {\n  let newStr = '';\n\n  let lastIndex: number;\n\n  if(end) {\n    lastIndex = end > str.length ? str.length : end;\n  } else {\n    lastIndex = str.length;\n  }\n\n  for (let i = start; i < lastIndex; i++) {\n    newStr += str[i];    \n  }\n\n  return newStr;\n}"},
    {"id": 3, "header": "Объекты", "content": "<span>Простейший способ записи типа объекта</span>\n\nconst carSimple: {\n  wheels: number,\n  brand: string,\n  type: string,\n} = {\n  wheels: 4,\n  brand: 'BMW',\n  type: 'Sedan',\n}\n\n<span>Использование interface для возможности переиспользовать тип с другим объектом</span>\n\ninterface Car {\n  wheels: number,\n  brand: string,\n  type: string,\n  isNew?: boolean, *\n  name?: string, **\n  [key: string]: unknown ***\n}\n\n<i>* Также как и в параметрах функции можно делать опциональные свойства для объекта. \n** Обычно опциональные свойства записывают после обязательных\n*** Данная запись позволяет добавлять дополнительные свойства для объекта</i>\n\nconst car: Car = {\n  wheels: 4,\n  brand: 'BMW',\n  type: 'Sedan',\n}\n\nconst car2: Car = {\n  wheels: 4,\n  brand: 'BMW',\n  type: 'Sedan',\n}\n\n\n<i>[key: string]: unknown - из-за данной строчки это будет работать\n\ncar2.go = true  \n\nВ популярном style гайде записывание допольнительных свойств происходит через скобки\n\ncar2['go2'] = true</i>"},
    {"id": 4, "header": "Объекты как параметры функции", "content": "<span>Когда мы используем объекты в качестве параметров функции, при типизации мы указываем минимальный набор параметров, которые нужны для работы функции. Сами объекты могут быть разными, главное, чтобы в них был указанный минимум</span>\n\nfunction printPoint(point: {x: string, y: string}): void {\n  console.log(`Point coord is x: ${point.x} and y: ${point.y}`);\n}\n\n<i>Работает и полностью соответствует типизации параметров функции</i>\n\nconst obj1 = {\n  x: '1',\n  y: '2'\n}\n\nprintPoint(obj1);\n\n<i>Тоже работает, так как имеет минимальный набор свойств, соответствующих типизации параметров функции</i>\n\nconst obj2 = {\n  x: '1',\n  y: '2'\n}\n\nprintPoint(obj2);\n\n<span>Также в функции могут быть и опциональные параметры,</span> <i>но чтобы функция работала корректно необходимо проверять их наличие через if, иначе из-за попытки вызова undefined аргумента мы получим ошибку</i> \n\nfunction printName(user: {firstName: string, lastName?: string}): void {\n  console.log(`Hello ${user.firstName.toUpperCase()}`);\n\n  if(user.lastName) {\n      console.log(`Nice to meet you mr/mis ${user.lastName.toUpperCase()}`);\n  }\n}\n\nprintName({firstName: 'Vladimir'});\nprintName({firstName: 'Vladimir', lastName: 'St'});"},
    {"id": 5, "header": "Массивы", "content": "<span>Типизация массивов</span>\n\nЧаще всего объекты массива имеют один конкретный тип данных\n\nconst numbers = [1,2,3,4];\n\n<i>TS автоматически определит что это массив чисел numbers[]</i>\n\nПри этом если дописывать новые типы, то он автоматически добавит и их\n(numbers|string|boolean)[]\n\nconst numbersAndOther = [1,2,3,4,'five', true];\n\n<i>При создании пустого массива надо явно указывать тип\nиначе будет any[]</i>\n\nconst arrStr: string[] = [];\n\nМенее частый вариант указания типа массива\n\nconst arrStr2: Array<string> = [];\n\nTS выдаст ошибку \n\narrStr.push(1);\n\n<span>Массивы также можно типизировать и объектами</span>\n\ninterface arrCar {\n  wheels: number;\n  brand: string;\n}\n\nconst cars: arrCar[] = [];\ncars.push({wheels: 4, brand: 'Audi'});\n\n<span>Типизация вложенного массива</span>\n\nconst arrOfArr: string[][] = [];\narrOfArr.push(['one', 'two']);\n\n<span>Использование в параметрах функции</span>\n\nfunction printArr(arr: unknown[]): void {\n  arr.forEach((el, index, array) => {\n    console.log(el, index, array);\n  })\n}\n\n<i>В данном случае el из arr.forEach автоматически подтянет свой тип\nиз arr:unknown[] в параметрах функции</i>"},
    {"id": 6, "header": "Кортежи(tuples)", "content": "<span>Типизация кортежей (tuples)</span>\n\nconst pairs: [string, string][] = [['key', 'value'], ['key2', 'value2']];\n\n<i>Пример использования, хранение табличных данных</i>\n\nconst doc: [string, string, number, Date][] = [];\ndoc.push(['Vladimir', 'St', 30, new Date()]);"},
    {"id": 7, "header": "Псевдонимы типов (Type Aliases)", "content": "<span>Псевдонимы типов (Type Aliases)</span>\n\n<i>Позволяет создавать свои типы данных, схожи с интерфейсами, но гибче</i>\n\ntype MyBoolean = false | true;\ntype Pair = [string, string];\ntype Pairs = Pair[];\n\n<i>Можно использовать и для типизации объекта</i>\n\ntype TypedCar = {\n  wheels: number,\n  brand: string,\n  type: string,\n  isNew?: MyBoolean,\n  name?: string,\n  [key: string]: unknown\n}"},
    {"id": 8, "header": "Union Types в TypeScript", "content": "<span>Тип Union</span> \n\n <i>Позволяет переменной принимать несколько возможных типов значений.</i> Его используют, когда данные могут быть разной природы, но при этом мы хотим сохранить строгую типизацию. В TypeScript union <i>обозначается вертикальной чертой</i> |, читается как «или».\n\n Простое определение:\n\n type Direction = 'up' | 'down' | 'left' | 'right';\n\n Переменная типа Direction может принимать только одно из четырёх значений. Любое другое значение будет отвергнуто компилятором. \n\n const move: Direction = 'left'; // ✅ корректно\n const move2: Direction = 'forward'; // ❌ ошибка компиляции\n\n <span>Union для разных примитивов</span>\n\n Union <i>позволяет комбинировать разные типы,</i> например числа и булевы значения:\n\n const mixedValues: (number | boolean)[] = [42, true, 0, false]; \n\n Здесь mixedValues — массив, элементы которого могут быть либо числами, либо булевыми значениями. TypeScript сохранит строгую типизацию и подскажет ошибки при добавлении неподходящих типов. \n\n <span>Union в функциях</span> \n\n Union удобно использовать в параметрах и возвращаемых значениях функций, когда возможны разные варианты данных:\n\n function describe(value: string | number): void {\n if (typeof value === 'string') console.log(`Строка: ${value.toLowerCase()}`);\n  else console.log(`Число: ${value * 2}`);\n }\n\n Если value — строка, мы применяем метод toLowerCase().\n Если value — число, умножаем на 2.\n\n TypeScript подсказывает, что нужно проверять типы внутри функции, чтобы код оставался безопасным.\n\n <span>Union и сложные структуры</span> \n\n Union также работает с массивами, объектами и кортежами, позволяя комбинировать разные формы данных:\n\n function greet(entity: { name: string } | string): void {\n if (typeof entity === 'string') {\n console.log(`Привет, ${entity}!`);\n } else {\n console.log(`Привет, ${entity.name}!`);\n }\n\n Параметр entity может быть строкой или объектом с полем name.\n Мы проверяем тип внутри функции и работаем с ним безопасно. }\n\n <span>Несколько нюансов Union Types</span> \n\n Тип Narrowing (сужение типа) \n\n TypeScript требует проверку типа внутри функций (typeof, Array.isArray, in), чтобы избежать ошибок.\n\n Можно объединять union с другими типами\n\n type Response = string | number | null | undefined;\n\n Union vs Any\n Union безопаснее, чем any, потому что ограничивает возможные варианты, при этом сохраняя гибкость."},
    {"id": 9, "header": "Enum в TypeScript", "content": "<span>Enum в TypeScript</span>\n\nВ TypeScript <i>enum</i> (перечисление) — это способ задать набор <i>именованных констант</i>. Они помогают сделать код читаемее, избегая магических чисел и строк, а также позволяют явно работать с фиксированными значениями.\n\n<span>1. Базовое использование enum</span>\n\nСоздадим перечисление с формами:\n\nts\nenum ShapeKind {\n  Triangle,\n  Rectangle,\n  Circle,\n}\n\nconst myShape = ShapeKind.Circle;\nconsole.log(myShape); // 2\n\n\nПо умолчанию TypeScript <i>нумерует элементы enum</i>, начиная с 0.\n\n<span>2. Enum и интерфейсы</span>\n\nEnum часто используют вместе с интерфейсами, чтобы типизировать объекты с фиксированными значениями:\n\nts\ninterface Triangle {\n  kind: ShapeKind.Triangle;\n  base: number;\n  height: number;\n}\n\ninterface Rectangle {\n  kind: ShapeKind.Rectangle;\n  width: number;\n  height: number;\n}\n\ninterface Circle {\n  kind: ShapeKind.Circle;\n  radius: number;\n}\n\nconst myTriangle: Triangle = {\n  kind: ShapeKind.Triangle,\n  base: 10,\n  height: 5,\n};\n\n\nЗдесь свойство <i>kind</i> выступает как дискриминатор — оно помогает TypeScript определять, какой именно тип передан.\n\n<span>3. Enum с кастомными значениями</span>\n\nМы можем присваивать <i>свои значения</i> элементам enum. Это полезно, когда нужно соответствовать HTTP-статусам, кодам ошибок или бизнес-константам:\n\nts\nenum StatusCode {\n  OK = 200,\n  NOT_FOUND = 404,\n  UNAUTHORIZED = 401,\n  SERVER_ERROR = 500,\n}\n\nconsole.log(StatusCode.NOT_FOUND); // 404\n\n\n<span>4. Enum в реальных сценариях</span>\n\nПример с авторизацией пользователя и выводом соответствующего кода ошибки:\n\nts\ninterface LoginPage {\n  username?: string;\n  password?: string;\n  isVerified: boolean;\n}\n\nfunction handleLogin(user: LoginPage): void {\n  if (!user.username || !user.password) {\n    console.log(`Ошибка: ${StatusCode.UNAUTHORIZED}`);\n  } else if (!user.isVerified) {\n    console.log(`Ошибка: ${StatusCode.SERVER_ERROR}`);\n  } else {\n    console.log(`Успех! Статус: ${StatusCode.OK}`);\n  }\n}\n\n\n<span>5. Числовые vs строковые enum</span>\n\nПо умолчанию TypeScript создаёт <i>числовые enum</i>, но можно использовать <i>строковые</i>:\n\nts\nenum Role {\n  Admin = 'ADMIN',\n  User = 'USER',\n  Guest = 'GUEST',\n}\n\nconst currentRole: Role = Role.User;\nconsole.log(currentRole); // \"USER\"\n\n\nКогда использовать строковые enum:\n- Если значение выводится пользователю\n- Если важно сохранить читаемость логов\n- Если строки логичнее чисел для бизнес-логики\n\n<span>6. Выводы</span>\n\n- <i>Enum</i> — это удобный способ задать фиксированный набор значений.\n- Поддерживают как <i>числовые</i>, так и <i>строковые</i> значения.\n- Отлично работают вместе с интерфейсами.\n- Повышают читаемость кода и снижают количество багов.\n\n⚙️ <i>Мудрость Омниссии</i>: \"Кто хранит enum — тот хранит порядок. Кто забывает о нём — пробуждает багов демонов.\""}
  ],
  "react": [{"id": 1, "header": "Что это", "content": "<i>React</i> — это JavaScript-библиотека для разработки пользовательского интерфейса."}],
  "exercises": [{"id": 1, "header": "Array.diff", "content": "Реализуйте функцию, которая вычисляет разницу между двумя списками. Функция должна удалить все вхождения элементов из первого списка (a), которые присутствуют во втором списке (b). Порядок элементов в первом списке должен быть сохранен в результате.\n\nПримеры:\n\nЕсли a = [1, 2] и b = [1], результат должен быть [2].\n\nЕсли a = [1, 2, 2, 2, 3] и b = [2], результат должен быть [1, 3]."},
  {"id": 2, "header": "Нарциссическое число (или число Армстронга)", "content": "Нарциссическое число (или число Армстронга) — это положительное число, которое равно сумме своих цифр, возведённых в степень, равную количеству цифр в данном основании. В данной задаче мы ограничимся десятичной системой (основание 10).\n\nНапример, возьмём число 153 (3 цифры), которое является нарциссическим:\n\n    1^3 + 5^3 + 3^3 = 1 + 125 + 27 = 153\n\nи число 1652 (4 цифры), которое не является:\n\n    1^4 + 6^4 + 5^4 + 2^4 = 1 + 1296 + 625 + 16 = 1938\n\nЗадача:\n\nВаш код должен возвращать true или false (не строки 'true' и 'false') в зависимости от того, является ли заданное число нарциссическим числом в base 10.\n\nВ вашем языке это может быть True и False, например, в PHP.\n\nПроверка на текстовые строки или другие недопустимые входные данные не требуется, в функцию будут передаваться только допустимые положительные ненулевые целые числа."},
  {"id": 3, "header": "Подсчёт гласных", "content": "Верните количество гласных в заданной строке.\n\nМы будем рассматривать a, e, i, o, u как гласные для этой задачи (но не y).\n\nВходная строка будет состоять только из строчных букв и/или пробелов."}]
}