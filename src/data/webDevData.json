{
  "jsLessons": [
    {"id": 1, "header": "Что такое", "content": "<span>Что такое JavaScript</span>\n\n  JavaScript — это кросс-платформенный, объектно-ориентированный скриптовый язык, являющийся небольшим и легковесным. Внутри среды исполнения JavaScript может быть связан с объектами данной среды и предоставлять программный контроль над ними. \n\n  <span>Содержимое</span> \n\n JavaScript включает стандартную библиотеку объектов, например, Array, Date и Math, а также базовый набор языковых элементов, например, операторы и управляющие конструкции. Ядро JavaScript может быть расширено для различных целей путём добавления в него новых объектов, например: JavaScript на стороне клиента расширяет ядро языка, предоставляя объекты для контроля браузера и его Document Object Model (DOM). Например, клиентские расширения позволяют приложению размещать элементы в форме HTML и обрабатывать пользовательские события, такие как щелчок мыши, ввод данных в форму и навигация по страницам. JavaScript на стороне сервера расширяет ядро языка, предоставляя объекты для запуска JavaScript на сервере. Например, расширение на стороне сервера позволяет приложению соединяться с базой данных, обеспечивать непрерывность информации между вызовами приложения или выполнять манипуляции над файлами на сервере."},
    {"id": 2, "header": "Грамматика и типы", "content": "<span>Основы</span> \n\n JavaScript чувствителен к регистру и использует кодировку символов Unicode. Например, слово Früh (\"рано\" по-немецки) может использоваться в качестве имени переменной. \n\n    В JavaScript инструкции называются statements и разделяются точкой с запятой (;). Пробел (space), табуляция (tab) и перевод строки (newline) называются пробельными символами (whitespace). Исходный текст скриптов на JavaScript сканируется слева направо и конвертируется в последовательность входных элементов, являющихся токенами (tokens), управляющими символами, символами конца строки, комментариями или пробельными символами. \n\n    ECMAScript также определяет некоторые ключевые слова и литералы и устанавливает правила для автоматической вставки точек с запятой (ASI), чтобы обозначить конец инструкций (statements). Однако, рекомендуется всегда ставить точку с запятой в конце каждой инструкции вручную, чтобы избежать побочных эффектов. Чтобы получить более подробную информацию, прочитайте Lexical Grammar."},
    {"id": 3, "header": "Объявления", "content": "<span>В JavaScript существует три вида объявлений</span> \n\n <i>var</i> \n\n Объявляет переменную, инициализация переменной значением является необязательной. \n\n <i>let</i> \n\n Объявляет локальную переменную в области видимости блока, инициализация переменной значением является необязательной.\n\n  <i>const</i> \n\n  Объявляет именованную константу, доступную только для чтения.\n\n <span>Переменные</span> \n\n  Вы можете использовать переменные как символические имена для значений в вашем приложении. Имена переменных называются <i>identifiers</i> и должны соответствовать определённым правилам.\n\n  Идентификатор в JavaScript должен начинаться с буквы, нижнего подчёркивания (_) или знака доллара ($); последующие символы могут также быть цифрами (0-9). Поскольку JavaScript чувствителен к регистру, буквы включают символы от \"A\" до \"Z\" (верхний регистр) и символы от \"a\" до \"z\" (нижний регистр). \n\n Вы можете использовать в идентификаторах буквы ISO 8859-1 или Unicode, например, å или ü. Вы также можете использовать управляющие последовательности Unicode как символы в идентификаторах. Некоторые примеры корректных имён: Number_hits, temp99, _name.\n\n <span>Объявление переменных</span>\n\n Вы можете объявить переменную тремя способами:\n\n <i>Используя ключевое слово var</i>. Например, var x = 42. Данный синтаксис может быть использован для объявления как локальных, так и глобальных переменных.\n\n <i>Просто присвоить переменной значение</i>. Например, x = 42. Переменные, объявленные данным способом, являются глобальными. Такое объявление генерирует строгое предупреждение (strict mode). Не рекомендуется использовать данный способ.\n\n <i>Используя ключевое слово let</i>. Например, let y = 13. Данный синтаксис может быть использован для объявления локальной переменной в области видимости блока."},
    {"id": 4, "header": "Присваивание значений", "content": "<span>Присваивание значений</span>\n\n Переменная, объявленная через var или let без присвоения начального значения, имеет значение undefined.\n\n При попытке доступа к необъявленной переменной или переменной до её объявления будет выброшено исключение ReferenceError:\n\n var a;\nconsole.log(\"The value of a is \" + a); //Значение переменной a undefined\n\nconsole.log(\"The value of b is \" + b); //Uncaught ReferenceError: b не определена\n\nconsole.log(\"The value of c is \" + c); //Значение переменной c undefined\nvar c;\n\nconsole.log(\"The value of x is \" + x); //Uncaught ReferenceError: x не определена\nlet x;\n\n <i>Вы можете использовать undefined, чтобы определить, имеет ли переменная значение.</i> В следующем примере переменной input не присвоено значение, и оператор if будет вычислен как true:\n\n var input;\nif (input === undefined) {\n  doThis();\n} else {\n  doThat();\n}\n\n Значение undefined ведёт себя как false, когда используется в <i>логическом контексте,</i> а также конвертируется в NaN, когда используется в <i>числовом контексте.</i>\n\n Значение <i>null</i> ведёт себя как 0 в числовом контексте и как false в логическом контексте."}
  ],
  "tsLessons": [
    {"id": 1, "header": "Переменные", "content": "  <span>Типизация numbers</span> \n\n   let x = 10;\n   let y = 5.5;\n   let z = NaN;\n\n <span>Типизация BigInt</span> \n\n   let bigX = 1321n; \n\n <span>Типизация string</span> \n\n  let str1 = \"boop\";\n  let str2: string;\n  str2 = \"hi\";\n\n  <span>Типизация symbol</span> \n\n  let symb = Symbol('as');\n\n <span>Типизация boolean</span> \n\n   let compare = true;\n   compare = false\n\n  <span>Типизация undefined</span> <i>(надо задавать самому, если не прописано в компиляторе)</i>\n\n  const missed: undefined = undefined;\n\n <span>Типизация null</span> <i>(надо задавать самому, если не прописано в компиляторе)</i> \n\n  const empty: null = null;\n\n <span>Типизация literal</span> <i>(конкретное значение, которое не может претерпевать изменений. Задается константой)</i>\n\n   const litNum = 777;\n   const litStr = 'lucky';\n\n <span>Отдельный тип any</span> <i>(Тип для крайнего случая как временная затычка, которую нужно в будущем править. Не дает подсказок после точки)</i>\n\n   let universal: any = 1;\n   universal = 'str';\n   universal = [];\n\n <span>Отдельный тип unknow</span> <i>(Используется когда тип переменной будет определяться в будущем. Не дает такой же свободы как и any, например требует проверки типа через условие)</i>\n\n   let unknown: unknown = \"lowercase\";\n   if(typeof unknown === \"string\") unknown.toUpperCase();"},
    {"id": 2, "header": "Функции", "content": "<span>Базовый синтаксис.</span>\n\nfunction sum(a: number, b: number): number {\n  return a + b;\n}\n\n <i>Параметры функции типизировать обязательно, возвращаемое значение обычно определяется правильно.</i> \n\n<span>Необычные возвращаемые типы</span>\n\nfunction log(name: string, userId?: string): void {\n  console.log(\"Log \", name, \" User Id is \", userId || \"none\");\n}\n\n <i>Тип \"void\" для возвращаемого значения функции обозначет, что она ничего не вернет, но завершится.\n Значек \"?\" после параметра функции показывает что он необязателен. \n Аргумент будет принимать и значения указанного типа и undefined.</i>\n\nfunction crash(): never {\n  throw new Error(\"crash\");\n}\n\n <i>Использование типа \"never\" указывает на то, что функция не будет завершена.</i>\n\n <span>Типизация параметра массива</span>\n\nfunction average(...nums: number[]): number {\n  const sum = nums.reduce((total, current) => total + current, 0);\n  return sum / nums.length;\n}\n\n <span>Примеры со стрелочной функций и функциональным выражением</span>\n\nconst sum2 = (a: number, b: number): number => {\n  return a + b;\n}\n\nconst sum3 = function (a: number, b: number): number {\n  return a + b;\n}\n\n <span>Упражнение</span>\n\nfunction slice(str: string, start: number, end?: number): string {\n  let newStr = '';\n\n  let lastIndex: number;\n\n  if(end) {\n    lastIndex = end > str.length ? str.length : end;\n  } else {\n    lastIndex = str.length;\n  }\n\n  for (let i = start; i < lastIndex; i++) {\n    newStr += str[i];    \n  }\n\n  return newStr;\n}"},
    {"id": 3, "header": "Объекты", "content": "<span>Простейший способ записи типа объекта</span>\n\nconst carSimple: {\n  wheels: number,\n  brand: string,\n  type: string,\n} = {\n  wheels: 4,\n  brand: 'BMW',\n  type: 'Sedan',\n}\n\n<span>Использование interface для возможности переиспользовать тип с другим объектом</span>\n\ninterface Car {\n  wheels: number,\n  brand: string,\n  type: string,\n  isNew?: boolean, *\n  name?: string, **\n  [key: string]: unknown ***\n}\n\n<i>* Также как и в параметрах функции можно делать опциональные свойства для объекта. \n** Обычно опциональные свойства записывают после обязательных\n*** Данная запись позволяет добавлять дополнительные свойства для объекта</i>\n\nconst car: Car = {\n  wheels: 4,\n  brand: 'BMW',\n  type: 'Sedan',\n}\n\nconst car2: Car = {\n  wheels: 4,\n  brand: 'BMW',\n  type: 'Sedan',\n}\n\n\n<i>[key: string]: unknown - из-за данной строчки это будет работать\n\ncar2.go = true  \n\nВ популярном style гайде записывание допольнительных свойств происходит через скобки\n\ncar2['go2'] = true</i>"},
    {"id": 4, "header": "Объекты как параметры функции", "content": "<span>Когда мы используем объекты в качестве параметров функции, при типизации мы указываем минимальный набор параметров, которые нужны для работы функции. Сами объекты могут быть разными, главное, чтобы в них был указанный минимум</span>\n\nfunction printPoint(point: {x: string, y: string}): void {\n  console.log(`Point coord is x: ${point.x} and y: ${point.y}`);\n}\n\n<i>Работает и полностью соответствует типизации параметров функции</i>\n\nconst obj1 = {\n  x: '1',\n  y: '2'\n}\n\nprintPoint(obj1);\n\n<i>Тоже работает, так как имеет минимальный набор свойств, соответствующих типизации параметров функции</i>\n\nconst obj2 = {\n  x: '1',\n  y: '2'\n}\n\nprintPoint(obj2);\n\n<span>Также в функции могут быть и опциональные параметры,</span> <i>но чтобы функция работала корректно необходимо проверять их наличие через if, иначе из-за попытки вызова undefined аргумента мы получим ошибку</i> \n\nfunction printName(user: {firstName: string, lastName?: string}): void {\n  console.log(`Hello ${user.firstName.toUpperCase()}`);\n\n  if(user.lastName) {\n      console.log(`Nice to meet you mr/mis ${user.lastName.toUpperCase()}`);\n  }\n}\n\nprintName({firstName: 'Vladimir'});\nprintName({firstName: 'Vladimir', lastName: 'St'});"},
    {"id": 5, "header": "Массивы", "content": "<span>Типизация массивов</span>\n\nЧаще всего объекты массива имеют один конкретный тип данных\n\nconst numbers = [1,2,3,4];\n\n<i>TS автоматически определит что это массив чисел numbers[]</i>\n\nПри этом если дописывать новые типы, то он автоматически добавит и их\n(numbers|string|boolean)[]\n\nconst numbersAndOther = [1,2,3,4,'five', true];\n\n<i>При создании пустого массива надо явно указывать тип\nиначе будет any[]</i>\n\nconst arrStr: string[] = [];\n\nМенее частый вариант указания типа массива\n\nconst arrStr2: Array&lt;string&gt; = [];\n\nTS выдаст ошибку \n\narrStr.push(1);\n\n<span>Массивы также можно типизировать и объектами</span>\n\ninterface arrCar {\n  wheels: number;\n  brand: string;\n}\n\nconst cars: arrCar[] = [];\ncars.push({wheels: 4, brand: 'Audi'});\n\n<span>Типизация вложенного массива</span>\n\nconst arrOfArr: string[][] = [];\narrOfArr.push(['one', 'two']);\n\n<span>Использование в параметрах функции</span>\n\nfunction printArr(arr: unknown[]): void {\n  arr.forEach((el, index, array) => {\n    console.log(el, index, array);\n  })\n}\n\n<i>В данном случае el из arr.forEach автоматически подтянет свой тип\nиз arr:unknown[] в параметрах функции</i>"},
    {"id": 6, "header": "Кортежи(tuples)", "content": "<span>Типизация кортежей (tuples)</span>\n\nconst pairs: [string, string][] = [['key', 'value'], ['key2', 'value2']];\n\n<i>Пример использования, хранение табличных данных</i>\n\nconst doc: [string, string, number, Date][] = [];\ndoc.push(['Vladimir', 'St', 30, new Date()]);"},
    {"id": 7, "header": "Псевдонимы типов (Type Aliases)", "content": "<span>Псевдонимы типов (Type Aliases)</span>\n\n<i>Позволяет создавать свои типы данных, схожи с интерфейсами, но гибче</i>\n\ntype MyBoolean = false | true;\ntype Pair = [string, string];\ntype Pairs = Pair[];\n\n<i>Можно использовать и для типизации объекта</i>\n\ntype TypedCar = {\n  wheels: number,\n  brand: string,\n  type: string,\n  isNew?: MyBoolean,\n  name?: string,\n  [key: string]: unknown\n}"},
    {"id": 8, "header": "Union Types в TypeScript", "content": "<span>Тип Union</span> \n\n <i>Позволяет переменной принимать несколько возможных типов значений.</i> Его используют, когда данные могут быть разной природы, но при этом мы хотим сохранить строгую типизацию. В TypeScript union <i>обозначается вертикальной чертой</i> |, читается как «или».\n\n Простое определение:\n\n type Direction = 'up' | 'down' | 'left' | 'right';\n\n Переменная типа Direction может принимать только одно из четырёх значений. Любое другое значение будет отвергнуто компилятором. \n\n const move: Direction = 'left'; // ✅ корректно\n const move2: Direction = 'forward'; // ❌ ошибка компиляции\n\n <span>Union для разных примитивов</span>\n\n Union <i>позволяет комбинировать разные типы,</i> например числа и булевы значения:\n\n const mixedValues: (number | boolean)[] = [42, true, 0, false]; \n\n Здесь mixedValues — массив, элементы которого могут быть либо числами, либо булевыми значениями. TypeScript сохранит строгую типизацию и подскажет ошибки при добавлении неподходящих типов. \n\n <span>Union в функциях</span> \n\n Union удобно использовать в параметрах и возвращаемых значениях функций, когда возможны разные варианты данных:\n\n function describe(value: string | number): void {\n if (typeof value === 'string') console.log(`Строка: ${value.toLowerCase()}`);\n  else console.log(`Число: ${value * 2}`);\n }\n\n Если value — строка, мы применяем метод toLowerCase().\n Если value — число, умножаем на 2.\n\n TypeScript подсказывает, что нужно проверять типы внутри функции, чтобы код оставался безопасным.\n\n <span>Union и сложные структуры</span> \n\n Union также работает с массивами, объектами и кортежами, позволяя комбинировать разные формы данных:\n\n function greet(entity: { name: string } | string): void {\n if (typeof entity === 'string') {\n console.log(`Привет, ${entity}!`);\n } else {\n console.log(`Привет, ${entity.name}!`);\n }\n\n Параметр entity может быть строкой или объектом с полем name.\n Мы проверяем тип внутри функции и работаем с ним безопасно. }\n\n <span>Несколько нюансов Union Types</span> \n\n Тип Narrowing (сужение типа) \n\n TypeScript требует проверку типа внутри функций (typeof, Array.isArray, in), чтобы избежать ошибок.\n\n Можно объединять union с другими типами\n\n type Response = string | number | null | undefined;\n\n Union vs Any\n Union безопаснее, чем any, потому что ограничивает возможные варианты, при этом сохраняя гибкость."},
    {"id": 9, "header": "Enum в TypeScript", "content": "<span>Enum в TypeScript</span>\n\nВ TypeScript <i>enum</i> (перечисление) — это способ задать набор <i>именованных констант</i>. Они помогают сделать код читаемее, избегая магических чисел и строк, а также позволяют явно работать с фиксированными значениями.\n\n<span>1. Базовое использование enum</span>\n\nСоздадим перечисление с формами:\n\nts\nenum ShapeKind {\n  Triangle,\n  Rectangle,\n  Circle,\n}\n\nconst myShape = ShapeKind.Circle;\nconsole.log(myShape); // 2\n\n\nПо умолчанию TypeScript <i>нумерует элементы enum</i>, начиная с 0.\n\n<span>2. Enum и интерфейсы</span>\n\nEnum часто используют вместе с интерфейсами, чтобы типизировать объекты с фиксированными значениями:\n\nts\ninterface Triangle {\n  kind: ShapeKind.Triangle;\n  base: number;\n  height: number;\n}\n\ninterface Rectangle {\n  kind: ShapeKind.Rectangle;\n  width: number;\n  height: number;\n}\n\ninterface Circle {\n  kind: ShapeKind.Circle;\n  radius: number;\n}\n\nconst myTriangle: Triangle = {\n  kind: ShapeKind.Triangle,\n  base: 10,\n  height: 5,\n};\n\n\nЗдесь свойство <i>kind</i> выступает как дискриминатор — оно помогает TypeScript определять, какой именно тип передан.\n\n<span>3. Enum с кастомными значениями</span>\n\nМы можем присваивать <i>свои значения</i> элементам enum. Это полезно, когда нужно соответствовать HTTP-статусам, кодам ошибок или бизнес-константам:\n\nts\nenum StatusCode {\n  OK = 200,\n  NOT_FOUND = 404,\n  UNAUTHORIZED = 401,\n  SERVER_ERROR = 500,\n}\n\nconsole.log(StatusCode.NOT_FOUND); // 404\n\n\n<span>4. Enum в реальных сценариях</span>\n\nПример с авторизацией пользователя и выводом соответствующего кода ошибки:\n\nts\ninterface LoginPage {\n  username?: string;\n  password?: string;\n  isVerified: boolean;\n}\n\nfunction handleLogin(user: LoginPage): void {\n  if (!user.username || !user.password) {\n    console.log(`Ошибка: ${StatusCode.UNAUTHORIZED}`);\n  } else if (!user.isVerified) {\n    console.log(`Ошибка: ${StatusCode.SERVER_ERROR}`);\n  } else {\n    console.log(`Успех! Статус: ${StatusCode.OK}`);\n  }\n}\n\n\n<span>5. Числовые vs строковые enum</span>\n\nПо умолчанию TypeScript создаёт <i>числовые enum</i>, но можно использовать <i>строковые</i>:\n\nts\nenum Role {\n  Admin = 'ADMIN',\n  User = 'USER',\n  Guest = 'GUEST',\n}\n\nconst currentRole: Role = Role.User;\nconsole.log(currentRole); // \"USER\"\n\n\nКогда использовать строковые enum:\n- Если значение выводится пользователю\n- Если важно сохранить читаемость логов\n- Если строки логичнее чисел для бизнес-логики\n\n<span>6. Выводы</span>\n\n- <i>Enum</i> — это удобный способ задать фиксированный набор значений.\n- Поддерживают как <i>числовые</i>, так и <i>строковые</i> значения.\n- Отлично работают вместе с интерфейсами.\n- Повышают читаемость кода и снижают количество багов.\n\n⚙️ <i>Мудрость Омниссии</i>: \"Кто хранит enum — тот хранит порядок. Кто забывает о нём — пробуждает багов демонов.\""},
    {"id": 10, "header": "Интерфейсы (interface)", "content": "<span>Интерфейсы в TypeScript</span> позволяют описывать структуру объектов, классов и функций. Они помогают обеспечить строгую типизацию и делают код более читаемым и гибким.\n\nИнтерфейс определяет форму объекта: какие свойства он должен иметь, их типы и можно ли их изменять.\n\n<span>Базовый пример</span>\n\ninterface User {\n  readonly username: string,\n  readonly email: string,\n  password: string,\n}\n\nconst newUser: User = {\n  username: 'Neo',\n  email: 'neo@matrix.io',\n  password: '1234',\n}\n\n<i>Свойства, помеченные как readonly, нельзя изменять после инициализации.</i>\n\n// newUser.username = 'Smith'; ❌ Ошибка\n\n<span>Расширение интерфейсов</span>\n\nВ TypeScript можно объявлять интерфейс с тем же именем несколько раз, и они будут объединяться.\n\ninterface User {\n  isAdmin?: boolean,\n}\n\nconst adminUser: User = {\n  username: 'Trinity',\n  email: 'trinity@matrix.io',\n  password: 'secure',\n  isAdmin: true,\n}\n\n<i>Свойства с ? являются опциональными — их можно указывать, а можно нет.</i>\n\n<span>Интерфейсы для встроенных объектов</span>\n\nИнтерфейсы можно расширять даже для глобальных объектов, например для window:\n\ninterface Window {\n  darkMode?: boolean,\n}\n\nwindow.darkMode = true;\nconsole.log(window.darkMode);\n\n<span>Наследование интерфейсов</span>\n\nИнтерфейсы могут наследоваться от других интерфейсов, объединяя их свойства.\n\ninterface Person {\n  readonly firstName: string,\n  lastName: string,\n  age?: number,\n  phone?: string,\n}\n\ninterface Employee extends User, Person {\n  startDate: Date,\n}\n\nconst employee: Employee = {\n  username: 'Morpheus',\n  email: 'morpheus@matrix.io',\n  password: 'zion',\n  firstName: 'Morpheus',\n  lastName: 'Leader',\n  startDate: new Date(),\n}\n\n<i>Интерфейс Employee теперь содержит все свойства из User и Person.</i>\n\n<span>Интерфейсы и классы</span>\n\nИнтерфейсы можно использовать для описания структуры классов.\n\ninterface Developer extends Employee {\n  skills: string[],\n  level?: 'junior' | 'middle' | 'senior',\n  introduce(): void,\n  code: () => void,\n}\n\nclass MyDeveloper implements Developer {\n  username = 'Agent';\n  email = 'agent@matrix.io';\n  password = 'matrix';\n  firstName = 'Smith';\n  lastName = 'Agent';\n  startDate = new Date();\n  skills = ['TypeScript', 'React'];\n  code = () => console.log('Coding in TypeScript...');\n  introduce() {\n    console.log(`Hello, I am ${this.firstName} ${this.lastName}`);\n  }\n}\n\nconst dev = new MyDeveloper();\ndev.introduce(); // Hello, I am Smith Agent\ndev.code(); // Coding in TypeScript...\n\n<span>Ключевые моменты:</span>\n\n- <i>Интерфейсы описывают форму данных, но не их реализацию.</i>\n- <i>Можно объединять несколько интерфейсов в один с помощью наследования.</i>\n- <i>readonly делает свойство доступным только для чтения.</i>\n- <i>? делает свойство опциональным.</i>\n- <i>Классы могут реализовывать интерфейсы, чтобы гарантировать строгую структуру.</i>"},
    {"id": 11, "header": "Объединение Алиасов(Merge Aliases)", "content": "<span>Type Aliases</span> в TypeScript позволяют задавать собственные имена для любых типов — от простых примитивов до сложных объектов. Но их настоящая сила раскрывается, когда мы начинаем <i>объединять</i> алиасы между собой.\n\nДля этого используются два основных оператора:\n\n<i>| (union)</i> — объединение вариантов, когда значение может быть <i>любым</i> из указанных типов.\n\n<i>& (intersection)</i> — пересечение, которое объединяет <i>свойства нескольких типов</i> в один.\n\n<span>1. Объединение (Union) типов</span>\n\nЕсли у нас есть несколько наборов возможных значений, можно создать новый тип, который поддерживает все варианты:\n\nts\ntype Status1 = 'pending' | 'success' | 'error';\ntype Status2 = 'draft' | 'archived' | 'error';\n\ntype CombinedStatus = Status1 | Status2;\n\nconst currentStatus: CombinedStatus = 'draft'; // ✅ корректно\n\n\n<i>В CombinedStatus будут доступны все строки: 'pending' | 'success' | 'error' | 'draft' | 'archived'.</i>\n\n<span>2. Пересечение (Intersection) типов</span>\n\nС помощью <i>&</i> можно указать, что переменная должна соответствовать <i>одновременно нескольким</i> типам:\n\nts\ntype StatusA = 'online' | 'offline' | 'busy';\ntype StatusB = 'busy' | 'away';\n\ntype CommonStatus = StatusA & StatusB;\n\nconst st: CommonStatus = 'busy'; // ✅ корректно\n\n\n<i>В CommonStatus останется только 'busy', потому что это единственное значение, встречающееся в обоих типах.</i>\n\n<span>3. Пересечение объектов</span>\n\nTypeScript позволяет объединять несколько объектных алиасов в один более сложный тип. Свойства <i>сливаются</i>, но если есть одинаковые — они должны быть совместимыми:\n\nts\ntype Base = { id: number; createdAt: Date };\ntype Details = { name: string; description?: string };\ntype Flags = { isActive: boolean; createdAt: Date };\n\ntype FullEntity = Base & Details & Flags;\n\nconst entity: FullEntity = {\n  id: 1,\n  name: 'New Entity',\n  isActive: true,\n  createdAt: new Date(),\n};\n\n\n<i>Свойство createdAt встречается и в Base, и в Flags, но оба типа совпадают (Date), поэтому ошибок нет.</i>\n\n<span>4. Сложные пересечения алиасов</span>\n\nТеперь рассмотрим, как можно создавать многоуровневые типы, комбинируя несколько алиасов:\n\nts\ntype Account = {\n  readonly email: string;\n  readonly login: string;\n  password: string;\n};\n\ntype Profile = {\n  firstName: string;\n  lastName: string;\n  phone?: string;\n  birthYear?: number;\n};\n\ntype Employee = {\n  hiredAt: Date;\n} & Account & Profile;\n\ntype Developer = {\n  skills: string[];\n  level?: 'junior' | 'middle' | 'senior';\n  introduce(): void;\n  writeCode: () => void;\n} & Employee;\n\nconst dev: Developer = {\n  email: 'dev@example.com',\n  login: 'superdev',\n  password: 'secure123',\n  firstName: 'Kate',\n  lastName: 'Smith',\n  hiredAt: new Date(),\n  skills: ['TypeScript', 'React', 'Node.js'],\n  introduce() {\n    console.log(`Привет! Я ${this.firstName}, разработчик уровня ${this.level || 'intern'}`);\n  },\n  writeCode() {\n    console.log('Пишу чистый код, да прибудет с ним Омниссия ⚙️');\n  },\n};\n\n\n<i>Здесь Developer наследует всё от Employee, который в свою очередь объединяет Account и Profile. В результате мы получаем мощную структуру с минимумом дублирования кода.</i>"},
    {"id": 12, "header": "Интерфейсы против Aлиасов", "content": "<span>Type Aliases</span> и <span>Interfaces</span> — это два инструмента в TypeScript, которые часто пересекаются по функциональности, но у каждого есть свои сильные стороны.\n\n<span>Type Aliases</span> позволяют создавать новые имена для любых типов — примитивов, объединений (union), пересечений (intersection), кортежей и функций. Алиасы хорошо подходят для сложных структур, но не поддерживают декларативный мёрджинг и не могут описывать глобальные объекты.\n\nПример:\nts\ntype Status = 'online' | 'offline' | 'busy';\ntype Point = [number, number];\ntype ApiResponse = { ok: boolean } & { data: string };\n\n\n<span>Interfaces</span> больше ориентированы на объекты и классы. Их можно расширять, объединять через повторное объявление, использовать с implements, а также применять для описания глобальных объектов вроде Window.\n\nПример:\nts\ninterface Person {\n  name: string;\n}\n\ninterface Person {\n  age?: number; // расширение интерфейса\n}\n\ninterface Loggable {\n  log(): void;\n}\n\nclass App implements Loggable {\n  log() {\n    console.log('App is running...');\n  }\n}\n\n\n<i>Когда что выбирать?</i>\n- Если описываешь объект, который должен расширяться — используй interface.\n- Если нужен union, intersection или кортеж — используй type.\n- Для классов интерфейсы дают удобный синтаксис через implements.\n\n<span>Вывод:</span> <i>type</i> — универсален и гибок, <i>interface</i> — идеален для объектов, классов и расширяемых контрактов."},
    {"id": 13, "header": "Сужение типов (Narrowing)", "content": "<span>Сужение типов (Narrowing)</span> — это процесс, при котором TypeScript уточняет возможный тип переменной внутри блока кода на основе проверок. Если переменная изначально имеет несколько возможных типов (union), то с помощью условий мы можем «сузить» её до конкретного.\n\n<span>Примеры сужения</span>\n\n<span>1. Проверка через typeof</span>\n<code>ts\nfunction printValue(value?: number | string) {\n  if (typeof value === \"string\") {\n    console.log(value.toUpperCase());\n  } else if (typeof value === \"number\") {\n    console.log(value.toFixed(2));\n  } else {\n    console.log(\"Нет значения\");\n  }\n}\n</code>\n\n<span>2. Проверка массивов и объектов</span>\n<code>ts\nfunction handleInput(input: string | string[] | null) {\n  if (Array.isArray(input)) {\n    console.log(\"Массив строк:\", input.join(\", \"));\n  } else if (typeof input === \"string\") {\n    console.log(\"Строка:\", input.toLowerCase());\n  } else {\n    console.log(\"Пустое значение\");\n  }\n}\n</code>\n\n<span>3. Проверка через instanceof</span>\n<code>ts\nfunction processData(data: number[] | Date) {\n  if (data instanceof Date) {\n    console.log(\"Сегодня:\", data.toDateString());\n  } else {\n    console.log(\"Количество элементов:\", data.length);\n  }\n}\n</code>\n\n<span>4. Проверка через оператор in</span>\n<code>ts\ntype Dog = { bark: () => void };\ntype Cat = { meow: () => void };\n\nfunction interact(pet: Dog | Cat) {\n  if (\"bark\" in pet) {\n    pet.bark();\n  } else {\n    pet.meow();\n  }\n}\n</code>\n\n<span>Итог</span>\n<i>Сужение типов</i> — это основной инструмент безопасной работы с union-типами.\n- typeof — для примитивов.\n- Array.isArray и проверки на null — для коллекций и объектов.\n- instanceof — для объектов, созданных классами.\n- in — для проверки наличия свойств у объектов."},
    {"id": 14, "header": "Защитники типов (Type Guards)", "content": "<span>Type Guards (Защитники типов)</span> — это специальные конструкции в TypeScript, которые помогают «защитить» код, уточняя тип переменной внутри определённой области видимости. Они особенно полезны при работе с объединениями (union types).\n\n<span>Пользовательские защитники</span>\n\nМожно написать функцию, которая возвращает специальный предикат <i>pet is Fish</i>. Это сообщает компилятору, что если функция вернула true, то объект имеет тип Fish.\n\n<code>ts\ntype Fish = { swim: () => void };\ntype Bird = { fly: () => void };\n\nfunction isFish(pet: Fish | Bird): pet is Fish {\n  return (pet as Fish).swim !== undefined;\n}\n\nfunction move(animal: Fish | Bird) {\n  if (isFish(animal)) {\n    animal.swim();\n  } else {\n    animal.fly();\n  }\n}\n</code>\n\nЗдесь <i>isFish</i> — это type guard, и внутри блока if (isFish(animal)) компилятор знает, что animal — это Fish.\n\n<span>Ошибочные type guards</span>\n\nВажно помнить, что не всякая проверка автоматически становится корректным защитником типов.\n\n<code>ts\nfunction isNull(val: any): val is null {\n  return !val;\n}\n\nconst zero = 0;\nif (isNull(zero)) {\n  console.log(\"Never been\", zero);\n}\n</code>\n\nЗдесь 0 попадает под условие !val, хотя это вовсе не null. Такой type guard создаёт ложное чувство безопасности.\n\n<span>Итог</span>\n- Type guards помогают сужать типы при работе с union.\n- Можно использовать встроенные (typeof, instanceof, in) или писать свои.\n- Нужно быть осторожным и не создавать защитников, которые вводят компилятор в заблуждение."},
    {"id": 15, "header": "Утверждения (Asserts)", "content": "<span>Assertions (утверждения)</span> в TypeScript позволяют явно «заставить» компилятор поверить, что переменная имеет определённый тип. Но помимо обычных <i>type assertion</i>, есть ещё более строгий инструмент — <span>asserts functions</span>.\n\n<span>Что такое asserts functions?</span>\n\nЭто специальные функции, которые ничего не возвращают, но сообщают компилятору, что после их вызова переменная гарантированно соответствует определённому типу. Используется синтаксис:\n\n<code>ts\nfunction myAssert(param: unknown): asserts param is string {\n  if (typeof param !== \"string\") {\n    throw new Error(\"Not a string!\");\n  }\n}\n</code>\n\nЕсли функция не выбросила ошибку, значит param теперь точно string.\n\n<span>Пример использования</span>\n\n<code>ts\ntype User = {\n  name: string,\n  displayName: string | null,\n}\n\nfunction assertDisplayName(user: User): asserts user is User & { displayName: string } {\n  if (!user.displayName) throw new Error(\"User has no displayName field\");\n}\n\nfunction logUserByDisplayName(user: User) {\n  assertDisplayName(user);\n  console.log(user.displayName.toLowerCase());\n}\n</code>\n\nЗдесь <i>assertDisplayName</i> проверяет, что у пользователя есть displayName. Если это условие не выполнено, выбрасывается ошибка, и код дальше не идёт. А если проверка прошла — компилятор точно знает, что displayName уже не null.\n\n<span>Пример с массивом</span>\n\n<code>ts\nfunction assertStringArray(arr: unknown): asserts arr is string[] {\n  if (!Array.isArray(arr) || !arr.every(el => typeof el === \"string\")) {\n    throw new Error(\"Not a string array\");\n  }\n}\n\nfunction logStrings(arr: unknown) {\n  assertStringArray(arr);\n  arr.forEach(str => console.log(str.toUpperCase()));\n}\n</code>\n\nТеперь <i>assertStringArray</i> гарантирует, что arr после проверки будет именно массивом строк.\n\n<span>Ошибочное использование</span>\n\nБудь осторожен: если функция написана неверно, TypeScript всё равно поверит её сигнатуре.\n\n<code>ts\nfunction assertIsNull(val: any): asserts val is null {\n  if (!val) return; // ❌ Ошибка: 0, \"\", undefined тоже пройдут проверку\n}\n\nconst zero = 0;\nassertIsNull(zero);\nconsole.log(zero.toFixed()); // Рантайм-ошибка!\n</code>\n\nКомпилятор «думает», что zero теперь null, хотя фактически это число. Такие ошибки показывают, что с <i>asserts</i> нужно быть особенно внимательным.\n\n<span>Сравнение: asserts vs type guards</span>\n- <i>Type guards</i> (например, pet is Fish) возвращают boolean и используются для ветвлений.\n- <i>Asserts</i> ничего не возвращают, но гарантируют, что если ошибка не выброшена, переменная обязательно имеет нужный тип.\n- Грубо говоря: type guard говорит «похоже на X», а assert говорит «это точно X».\n- Использовать asserts лучше, когда неверный тип — это критическая ошибка, которую нужно остановить через throw."},
    {"id": 16, "header": "This (Контекст)", "content": "В JavaScript ключевое слово <span>this</span> часто ведёт себя неоднозначно: его значение зависит от контекста вызова функции. TypeScript помогает сделать работу с ним более безопасной, позволяя явно указывать тип <i>this</i> внутри функций и методов.\n\n<span>this в объектах</span>\n\nКогда мы описываем объект, методы автоматически получают доступ к своему контексту через <i>this</i>. Чтобы TypeScript понимал это, можно явно указать сигнатуру this:\n\n<code>ts\nconst user = {\n  id: 123,\n  admin: false,\n  becomeAdmin: function (this: { id: number; admin: boolean }) {\n    this.admin = true;\n  }\n};\n\nuser.becomeAdmin();\nconsole.log(user.admin); // true\n</code>\n\n<span>this в обработчиках событий</span>\n\nОсобенно важно указывать this при работе с DOM и обработчиками событий. Без этого TypeScript может посчитать this равным any.\n\n<code>ts\n < button id=\"myBtn\" onClick=\"MyClickHandler\" >Click Me!< / button   >\n\nfunction MyClickHandler(\n  this: HTMLButtonElement,\n  event: Event\n) {\n  this.disabled = true; // корректно: this — HTMLButtonElement\n}\n\nconst btn = document.getElementById(\"myBtn\") as HTMLButtonElement;\nbtn.addEventListener(\"click\", MyClickHandler);\n</code>\n\n<span>this в классах</span>\n\nВ классах <i>this</i> указывает на текущий экземпляр. TypeScript автоматически понимает его тип.\n\n<code>ts\nclass Counter {\n  private count = 0;\n\n  increment() {\n    this.count++;\n    console.log(`Count = ${this.count}`);\n  }\n}\n\nconst c = new Counter();\nc.increment(); // Count = 1\n</code>\n\n<span>Проблема потери контекста</span>\n\nЕсли метод класса передать как колбэк, он может потерять свой контекст <i>this</i>.\n\n<code>ts\nclass Greeter {\n  constructor(public message: string) {}\n\n  greet() {\n    console.log(this.message);\n  }\n}\n\nconst g = new Greeter(\"Hello!\");\nsetTimeout(g.greet, 1000); // Ошибка: this === undefined\n</code>\n\nРешение: привязать контекст через bind или использовать стрелочную функцию:\n\n<code>ts\nclass GreeterFixed {\n  constructor(public message: string) {}\n\n  greet = () => {\n    console.log(this.message);\n  }\n}\n\nconst g2 = new GreeterFixed(\"Hello fixed!\");\nsetTimeout(g2.greet, 1000); // корректно\n</code>\n\n<span>this и стрелочные функции</span>\n\nУ стрелочных функций нет собственного this — они берут его из внешнего контекста. Поэтому в них нельзя явно указать тип this, и TypeScript просто использует то, что видно снаружи.\n\n<code>ts\nconst obj = {\n  value: 42,\n  show: function () {\n    const arrow = () => {\n      console.log(this.value); // this = obj\n    };\n    arrow();\n  }\n};\n\nobj.show(); // 42\n</code>\n\n<span>Итог</span>\n- <i>this</i> можно явно типизировать в функциях и методах.\n- В классах TypeScript сам понимает this, но нужно следить за потерей контекста.\n- Стрелочные функции берут this из внешнего скоупа.\n- Для DOM-обработчиков особенно важно указывать тип this, чтобы избежать ошибок."},
    {"id": 17, "header": "Перегрузки функций (Overloads)", "content": "В JavaScript функция может принимать разные аргументы и возвращать разные значения в зависимости от условий. TypeScript позволяет это типизировать через <span>overloads</span> (перегрузки функций).\n\n<span>Что такое overloads?</span>\n\nПерегрузка функции — это возможность задать несколько сигнатур для одной и той же функции. Каждая сигнатура описывает свой набор аргументов и возвращаемый тип. При этом сама реализация остаётся одна.\n\n<span>Простой пример</span>\n\n<code>ts\nfunction add(a: number, b: number): number;\nfunction add(a: string, b: string): string;\nfunction add(a: any, b: any): any {\n  return a + b;\n}\n\nadd(1, 1);       // number\nadd(\"3\", \"4\");   // string\n</code>\n\nЗдесь у функции add две перегрузки:\n- если оба аргумента числа → результат число,\n- если оба строки → результат строка.\n\nРеализация использует any, но наружу TypeScript видит именно строгие сигнатуры.\n\n<span>Перегрузки с колбэком и Promise</span>\n\nБывает, что функция может работать синхронно и асинхронно. В таких случаях перегрузки помогают описать оба сценария.\n\n<code>ts\ntype AsyncCb = (res: number) => number;\n\nfunction asyncSum(a: number, b: number): Promise&lt;number&gt;;\nfunction asyncSum(a: number, b: number, cb: AsyncCb): number;\nfunction asyncSum(a: number, b: number, cb?: AsyncCb): any {\n  const result = a + b;\n  if (cb) return cb(result);\n  return Promise.resolve(result);\n}\n\nasyncSum(1, 3).then(console.log);     // Promise&lt;number&gt;\nasyncSum(2, 5, (r) => r * 2);         // number\n</code>\n\nТаким образом, одна функция поддерживает два режима:\n- без колбэка → возвращает Promise&lt;number&gt;,\n- с колбэком → возвращает number.\n\n<span>Перегрузка по числу аргументов</span>\n\n<code>ts\nfunction log(message: string): void;\nfunction log(message: string, level: \"info\" | \"warn\" | \"error\"): void;\nfunction log(message: string, level: string = \"info\"): void {\n  console[level](`[${level}] ${message}`);\n}\n\nlog(\"System started\");             // по умолчанию \"info\"\nlog(\"Low disk space\", \"warn\");     // предупреждение\nlog(\"Fatal error\", \"error\");       // ошибка\n</code>\n\nЭтот пример показывает, что перегрузки полезны и для случаев, когда у функции может быть разное количество аргументов.\n\n<span>Итог</span>\n- Перегрузки позволяют задать несколько сигнатур для одной функции.\n- Они помогают описывать разные режимы работы одной и той же логики.\n- Важно: реализация функции должна уметь корректно обработать все варианты."},
    {"id": 18, "header": "Рекурсивные типы", "content": "<span>Рекурсивные типы в TypeScript</span>  \n\n<i>Рекурсивные типы</i> позволяют описывать структуры данных, которые могут ссылаться сами на себя. Это полезно, когда мы имеем дело с вложенными структурами: деревья, JSON, рекурсивные массивы.  \n\n<span>Пример 1: вложенные массивы</span>  \n\nts\ntype NestedNumbers = number | NestedNumbers[];\n\nconst nums: NestedNumbers = [3213, 12, [3212, 42123, [112314, [5123213]]]];\nnums.push(231);\nnums.push([321, [32313]]);\n\n\nЗдесь <i>NestedNumbers</i> может быть либо числом, либо массивом таких же <i>NestedNumbers</i>. Таким образом можно строить бесконечно вложенные массивы чисел.  \n\n<span>Пример 2: JSON-структуры</span>  \n\nts\ntype JSONPrimitive = string | number | boolean;\ntype JSONObject = { [k: string]: JSONValue };\ntype JSONArray = JSONValue[];\ntype JSONValue = JSONPrimitive | JSONObject | JSONArray;\n\nfunction isJSON(arg: JSONValue) {}\n\nisJSON('hi');\nisJSON(1);\nisJSON({ a: [321], b: { c: 32131 } });\nisJSON([1, { d: 'boop' }]);\n\n\nЗдесь <i>JSONValue</i> рекурсивно ссылается на себя:  \n- Оно может быть <i>примитивом</i> (string | number | boolean),  \n- Объектом (<i>JSONObject</i>), где значения снова JSONValue,  \n- Или массивом (<i>JSONArray</i>), который тоже хранит JSONValue.  \n\nТакой подход идеально подходит для типизации любых JSON-подобных данных.  \n\n<span>Вывод</span>  \n\nРекурсивные типы позволяют:  \n- Описывать <i>деревья и вложенные структуры</i> (меню, дерево компонентов).  \n- Типизировать <i>сложные данные</i> вроде JSON.  \n- Делать строгие проверки типов даже в глубоко вложенных структурах.  \n\n"},
    {"id": 19, "header": "Оператор !", "content": "<span>Оператор ! (Non-null Assertion Operator)</span>\n\nВ TypeScript часто приходится иметь дело с переменными, которые могут быть <i>null</i> или <i>undefined</i>. При попытке работать с ними напрямую компилятор выдаёт ошибку, требуя проверки.\n\nОператор <i>!</i> говорит компилятору: «Я точно знаю, что тут не null и не undefined».\n<i>Важно понимать</i>: это обещание лежит на тебе, а не на компиляторе. Ошибка в логике приведёт к краху программы.\n\n<span>Пример с переменной</span>\n\n<code>\nlet message: string | null = null;\n\nconst isActive = true;\n\nif (isActive) {\n  message = \"System online\";\n}\n\nconsole.log(message!.toUpperCase()); // \"SYSTEM ONLINE\"\n</code>\n\n<span>Функции и параметры</span>\n\n<code>\nfunction greet(name?: string) {\n  const safeName: string = name!;\n  console.log(\"Hello, \" + safeName);\n}\n\ngreet(\"Marcus\"); // Hello, Marcus\n</code>\n\nБез <i>!</i> компилятор ругался бы, так как параметр name может быть <i>undefined</i>.\n\n<span>С интерфейсами</span>\n\n<code>\ninterface User {\n  username: string;\n  email?: string;\n}\n\nfunction printUser(user?: User) {\n  console.log(user!.username); // гарантируем что user не undefined\n}\n\nprintUser({ username: \"Luna\" });\n</code>\n\n<span>В работе с массивами</span>\n\n<code>\nconst numbers: number[] = [1, 2, 3, 4, 5];\n\nconst found = numbers.find(num => num > 3)!;\n\nconsole.log(found * 2); // 8\n</code>\n\nМетод <i>find</i> может вернуть <i>undefined</i>, но если мы точно уверены в результате — используем <i>!</i>.\n\n<span>Вывод</span>\n\nОператор <i>!</i> полезен, когда мы уверены в значении, но не стоит злоупотреблять им.\n<i>Лучше лишний раз добавить проверку</i>, чем сломать программу в рантайме."},
    {"id": 20, "header": "Дженерики", "content": "<span>Дженерики</span> (<i>Generics</i>) — это механизм TypeScript, позволяющий создавать <i>обобщённые типы</i> и функции, которые могут работать с разными типами данных, сохраняя строгую типизацию. Благодаря им можно писать более гибкий и переиспользуемый код.<br/><br/>\n\n<span>Основные определения:</span><br/>\n<i>Дженерик</i> — параметр типа, который задаётся в угловых скобках <code>&lt;&gt;</code>.<br/>\n<i>Обобщённая функция</i> — функция, которая принимает дженерик и может работать с разными типами.<br/>\n<i>Обобщённый интерфейс</i> — интерфейс, в котором тип одного или нескольких полей задаётся дженериком.<br/><br/>\n\n<span>Пример простого использования:</span><br/>\n<code>type Box&lt;T&gt; = T;\n\nconst box1: Box&lt;string&gt; = \"Привет\";\nconst box2: Box&lt;number&gt; = 123;</code><br/><br/>\n\n<span>Обобщённые функции:</span><br/>\n<code>export function toArray&lt;T&gt;(...args: T[]): T[] {\n  return args;\n}\n\nconst nums = toArray&lt;number&gt;(1, 2, 3);\nconst strs = toArray(\"a\", \"b\", \"c\");</code><br/><br/>\n\n<span>Перегрузка функций с дженериками:</span><br/>\n<code>function head(value: string): string;\nfunction head(value: readonly []): undefined;\nfunction head&lt;T&gt;(value: readonly T[]): T;\nfunction head(value: any): any {\n  return value[0];\n}\n\nconst firstNum = head([10, 20, 30]);\nconst firstChar = head(\"typescript\");</code><br/><br/>\n\n<span>Обобщённые интерфейсы:</span><br/>\n<code>interface ModelData&lt;T&gt; {\n  title: string;\n  value: T;\n}\n\nconst item1: ModelData&lt;number&gt; = {\n  title: \"Число\",\n  value: 42\n};\n\nconst item2: ModelData&lt;number&#91;&#93;&gt; = {\n  title: \"Список чисел\",\n  value: [1, 5, 9]\n};</code><br/><br/>\n\n<span>Вывод:</span><br/>\n<i>Дженерики</i> позволяют писать универсальный код, избегая дублирования и сохраняя строгую типизацию. Это один из ключевых инструментов для построения гибких библиотек и сложных приложений в TypeScript."},
    {"id": 21, "header": "Уточнения дженериков", "content": "<span>Уточнения дженериков</span> (<i>generic constraints</i>) — это механизм в TypeScript, позволяющий ограничивать возможные типы, которые могут быть подставлены в дженерик. То есть, мы явно указываем, что параметр должен соответствовать определённым условиям.<br/><br/>\n\n<span>Основные определения:</span><br/>\n<i>extends</i> — ключевое слово, которое накладывает ограничение на тип.<br/>\n<i>constraint</i> — условие, которому должен удовлетворять дженерик.<br/><br/>\n\n<span>Пример: ограничение по полю <code>length</code></span><br/>\n<code>export function len&lt;T extends { length: number }&gt;(arg: T): number {\n  return arg.length;\n}\n\nlen(\"typescript\"); // строка имеет length\nlen([1, 2, 3]);    // массив имеет length\nlen({ length: 10 }); // объект с полем length</code><br/><br/>\n\n<i>Неверные вызовы</i> приведут к ошибке:<br/>\n<code>len(123);      // Ошибка, number не имеет length\nlen(false);     // Ошибка, boolean не имеет length\nlen({ a: 10 }); // Ошибка, объект без поля length</code><br/><br/>\n\n<span>Пример: ограничение до объекта</span><br/>\n<code>function getArrFromObj&lt;T extends object&gt;(obj: T) {\n  return Object.values(obj);\n}\n\nconst objOfNums = { a: 1, b: 2, c: 3 };\nconst newArr = getArrFromObj(objOfNums);\nconsole.log(newArr); // [1, 2, 3]</code><br/><br/>\n\n<span>Вывод:</span><br/>\nИспользуя <i>уточнения дженериков</i>, мы можем описывать более строгие и полезные функции. Это делает код надёжнее, так как мы заранее отсекаем неподходящие типы и избегаем ошибок выполнения."},
    {"id": 22, "header": "keyof/комбинация с extends", "content": "<span>Оператор <code>keyof</code></span> в TypeScript используется для получения множества ключей типа объекта или массива. Результатом применения <code>keyof</code> является <i>объединение строковых литералов</i>, представляющих возможные ключи.<br/><br/>\n\n<span>Пример с глобальным объектом <code>Window</code></span><br/>\n<code>type WindowProp = keyof Window;\nconst myValue: WindowProp = \"oncopy\"; // допустимое свойство объекта Window</code><br/><br/>\n\n<span>Пример с интерфейсом</span><br/>\n<code>interface PC {\n  brand: string,\n  year: number\n}\n\ntype Typ1 = keyof PC;\nconst newPc: Typ1 = \"year\"; // ключ доступен, так как есть в PC</code><br/><br/>\n\n<span>Пример с кортежем</span><br/>\n<code>type Tup = keyof [number, string];\nconst Tuple: Tup = \"every\"; // методы массива\nconst Tuple2: Tup = \"1\";     // индекс как строка</code><br/><br/>\n\n <span>Комбинация <code>keyof</code> и <code>extends</code></span>\n\nКомбинация <code>keyof</code> и <code>extends</code> позволяет создавать функции и типы, которые работают только с допустимыми ключами объекта. Это повышает безопасность типов и предотвращает ошибки обращения к несуществующим свойствам.\n\n<span>Пример функции с ограничением</span>\n\n<code>export function prop&lt;T, U extends keyof T&gt;(key: U, obj: T): T&#91;U&#93; {\n  return obj[key];\n}\n\nconst obj = { a: 1, b: 2, c: 3 };\nprop('b', obj); // вернёт 2\n// prop('z', obj); // ошибка: ключа 'z' нет в obj</code>\n\n<span>Доступ к типу свойства через индекс</span>\n\n<code>interface Boots {\n  price: number;\n}\n\ntype P = Boots&#91;'price'&#93;; // тип P: number</code>\n\n<span>Вывод</span>\n </span>\nОператор <code>keyof</code> позволяет динамически получать допустимые ключи у типа. Это особенно полезно при написании <i>дженериков</i> и <i>утилитных типов</i>, так как мы можем строить функции или типы, которые работают только с корректными свойствами объекта. \n\n Используя <code>U extends keyof T</code>, мы можем описывать функции и типы, которые принимают только реальные ключи объекта <i>T</i>. А через запись <code>Type['prop']</code> можно получить тип конкретного свойства."},
    {"id": 23, "header": "Значения по умолчанию", "content": "<span>Значения по умолчанию в дженериках</span>\n\nИногда удобно задать <i>тип по умолчанию</i> для дженерика. Это позволяет использовать функцию или интерфейс даже без явного указания параметра, при этом тип будет подставлен автоматически.\n\n<span>Пример с функцией</span>\n\n<code>interface defaultObj {\n  &#91;key: string&#93;: unknown,\n}\n\nexport async function request&lt;T = defaultObj&gt;(url: string): Promise&lt;T&gt; {\n  const response = await fetch(url);\n  return response.json();\n}\n\nconst data = request(''); // data: defaultObj</code>\n\nЗдесь мы указали <code>T = defaultObj</code>. Это значит, что если не передать явный тип, то функция вернёт <i>defaultObj</i>.\n\n<span>Замещение типа по умолчанию</span>\n\n<code>interface Todo {\n  id: string,\n  completed: boolean,\n  title: string,\n}\n\nconst todoData = request&lt;Todo[]&gt;(''); // data: Todo[]</code>\n\nЕсли мы явно передаём параметр <code>&lt;Todo[]&gt;</code>, то значение по умолчанию заменяется указанным типом.\n\n<span>Вывод</span>\n\nЗначения по умолчанию в дженериках позволяют писать более <i>гибкий</i> и <i>универсальный</i> код. Они упрощают использование функций и интерфейсов, так как тип указывать каждый раз вручную не требуется."},
    {"id": 24, "header": "Scope", "content": "<span>Области видимости параметров типов</span>\n\n<i>Параметры типов</i>, заданные в обобщённой функции, принадлежат её собственной области видимости. Это значит, что:\n\n- Вложенные функции <i>могут использовать</i> параметры типов внешней функции, потому что находятся внутри её области.\n- Но они <i>не могут переопределять</i> эти параметры типов — если нужна своя обобщённость, внутренняя функция должна ввести новые параметры (например, <span>U</span>).\n\n<code>\nexport function tuplePairCreator&lt;T&gt;(first: T) {\n  return function&lt;U&gt;(second: U) {\n    return [first, second]; // здесь виден и T, и U\n  }\n}\n\nconst pair1 = tuplePairCreator(42)(\"answer\"); // [42, \"answer\"]\nconst pair2 = tuplePairCreator(\"x\")(true);    // [\"x\", true]\n</code>\n\nТаким образом, <span>T</span> из внешней функции доступен и обязателен для исполнения внутри вложенной, но принадлежит он именно внешней области.\n\n<span>Зачем это нужно?</span>\n\nТакой подход позволяет строить более <i>гибкие</i> конструкции, где один параметр типа «запоминается», а второй уточняется позже. Это напоминает <i>частичное применение</i> (partial application) функций, но уже на уровне типов.\n\n<span>Вывод</span>\n\nКаждый дженерик имеет свою область видимости. Это нужно учитывать, чтобы правильно проектировать вложенные функции и избегать конфликтов между параметрами типов."},
    {"id": 25, "header": "Conditional", "content": "<span>Условные типы</span>\n\n<i>Conditional types</i> — это тернарный синтаксис в пространстве типов: T extends U ? X : Y. Он позволяет выбирать тип в зависимости от того, удовлетворяет ли T условию extends.\n\n<span>Простой пример</span>\n\n<code>\ninterface StringRecord { [key: string]: string }\ninterface DateRecord { [key: string]: Date }\n\ntype MyRecord&lt;T&gt; = T extends string ? StringRecord : DateRecord;\n\ntype Obj1 = MyRecord&lt;string&gt;; // StringRecord\ntype Obj2 = MyRecord&lt;number&gt;; // DateRecord\n\nconst o1: Obj1 = { prop: 'Im StringRecord' };\n</code>\n\n<span>Дистрибутивность по объединениям</span>\n\nЕсли параметр типа — объединение, условный тип распределяется по членам объединения. Пример:\n\n<code>\ntype Dist&lt;T&gt; = T extends string ? T[] : never;\ntype R = Dist<'a' | 'b'>; // равно 'a'[] | 'b'[] (распределилось)\n</code>\n\nЕсли ты не хочешь распределения — заверни тип в кортеж:\n\n<code>\ntype NoDist&lt;T&gt; = [T] extends [string] ? true : false;\n</code>\n\n<span>Практические применения</span>\n\n- Создание условных маппингов (например, разные структуры для строк и чисел). Построение утилитных типов, зависящих от формы переданного типа.\n<span>Вывод</span>\n\nУсловные типы — очень мощный инструмент метапрограммирования в TypeScript. Главное помнить про дистрибутивность и при необходимости использовать \"обёртки\" (кортежи) для контроля поведения."},
    {"id": 26, "header": "infer", "content": "<span>infer</span>\n\n<i>infer</i> используется внутри условных типов и позволяет «вытянуть» (инферировать) часть типа при срабатывании шаблона. Это полезно, когда нужно извлечь, например, первый аргумент функции или тип аргумента конструктора.\n\n<span>Извлечение первого аргумента функции</span>\n\n<code>\nfunction fromPair(pair: [string, string]) {\n const [key, value] = pair;\n return { [key]: value };\n}\n\n// FirstArg вытаскивает тип первого аргумента функции\ntype FirstArg&lt;T&gt; = T extends (first: infer First, ...args: any[]) => any ? First : never;\n\nconst myPair: FirstArg&lt;typeof fromPair> = ['myKey', 'myValue'];\nfromPair(myPair);\n</code>\n\n<span>Извлечение аргумента конструктора</span>\n\n<code>\ntype ConstructorFirstArg&lt;T&gt; = T extends { new(arg: infer A, ...args: any[]): any } ? A : never;\n\nclass Computer { constructor(brand: string) {} }\n\nlet brand: ConstructorFirstArg&lt;typeof Computer> = 'intel';\nlet dateArg: ConstructorFirstArg&lt;typeof Date> = 12312312; // для Date конструктор принимает число (timestamp)\n</code>\n\n<span>Нюансы и рекомендации</span>\n\n- infer работает только внутри условного типа (extends). Часто используется для построения удобных утилит (например, извлечение типов параметров, возвращаемых значений, элементов кортежей и т.п.). Бывает сложен для чтения — документируй утилиты и давай им говорящие имена.\n\n<span>Вывод</span>\n\n<i>infer</i> даёт очень гибкие возможности для мета-типизации: с его помощью можно безопасно «разбирать» сложные типы и делать код более выразительным и повторно используемым."},
    {"id": 27, "header": "Маппинг типов", "content": "<span>Маппинг типов</span>\n\n<i>Mapped types</i> позволяют создавать новые типы на основе существующих наборов ключей. Это мощный инструмент генерации типов, особенно когда нужно описать объекты с повторяющимися структурами.\n\n<span>Общий синтаксис</span>\n\n<code>\ntype NewType&lt;K extends keyof any, T> = {\n [P in K]?: T\n}\n</code>\n\n- <i>K</i> — множество ключей (обычно строковые литералы или объединения строк). \n- <i>T</i> — тип значения, которое будет связано с ключами. \n- В квадратных скобках [P in K] происходит итерация по ключам. \n- Вопросительный знак ? делает ключи необязательными. \n\n<span>Пример 1. Каталог брендов ПК</span>\n\n<code>\ntype PcBrand = {\n name: string,\n country: string,\n founded: number,\n}\n\ntype PopularBrands = 'asus' | 'acer' | 'msi' | 'gigabyte';\n\ntype PcCatalog = {\n [BrandKey in PopularBrands]?: PcBrand\n}\n\nconst catalog: PcCatalog = {\n asus: {\n name: 'Asus',\n country: 'Taiwan',\n founded: 1989,\n },\n}\n\nfunction printCatalog(c: PcCatalog) {\n console.log(c.acer?.country);\n}\n</code>\n\nЗдесь мы прошлись по ключам PopularBrands и сопоставили им объект PcBrand. Все свойства сделаны опциональными.\n\n<span>Пример 2. Выбор частей из Window</span>\n\n<code>\ntype PartialWindow = {\n [Key in 'document' | 'location' | 'navigator']?: Window[Key]\n}\n\nconst pw: PartialWindow = {\n location: window.location,\n}\n</code>\n\nМы собрали новый тип объекта, где ключи соответствуют отдельным свойствам глобального объекта Window. Значения автоматически подхватывают типы этих свойств.\n\n<span>Вывод</span>\n\n<i>Mapped types</i> позволяют писать менее повторяющийся и более гибкий код, создавая типы из наборов ключей. Они активно применяются внутри утилитных типов TypeScript (Partial, Required, Readonly, Record)"},
    {"id": 28, "header": "Extract Exclude", "content": "В TypeScript существуют <i>утилиты для работы с объединениями типов</i>. Рассмотрим три из них: <code>Exclude</code>, <code>Extract</code> и <code>NonNullable</code>.\n\n<span>Exclude</span>\n<i>Exclude&lt;UnionType, ExcludedMembers&gt;</i> — исключает из объединения те члены, которые совпадают с <code>ExcludedMembers</code>.\n<code>type A0 = Exclude&lt;'a' | 'b' | 'c', 'a'&gt;;            // 'b' | 'c'\ntype A1 = Exclude&lt;'a' | 'b' | 'c', 'a' | 'b' | 'c'&gt;; // never\ntype A2 = Exclude&lt;string | number | (() =&gt; void), Function&gt;; // string | number\n\ntype Status = 'success' | 'clientError' | 'serverError' | 200 | 401 | 504;\ntype NumericStatus = Exclude&lt;Status, string&gt;; // 200 | 401 | 504\ntype StringStatus = Exclude&lt;Status, number&gt;; // 'success' | 'clientError' | 'serverError'</code>\n\n<span>Extract</span>\n<i>Extract&lt;UnionType, Members&gt;</i> — выбирает из объединения только те члены, которые совпадают с <code>Members</code>.\n<code>type B0 = Extract&lt;'a' | 'b' | 'c', 'a'&gt;;            // 'a'\ntype B1 = Extract&lt;'a' | 'b' | 'c', 'a' | 'b' | 'c'&gt;; // 'a' | 'b' | 'c'\ntype B2 = Extract&lt;string | number | (() =&gt; void), Function&gt;; // () =&gt; void\n\ninterface Person {\n  firstName: string,\n  lastName: string,\n  sex: 'male' | 'female',\n  phone: string,\n  yearOfBirth: number,\n  skills: string[]\n}\n\ntype PersonNames = Extract&lt;keyof Person, 'firstName' | 'lastName' | 'fullName'&gt;; // 'firstName' | 'lastName'</code>\n\n<span>NonNullable</span>\n<i>NonNullable&lt;T&gt;</i> — исключает из типа <code>null</code> и <code>undefined</code>.\n<code>type C0 = NonNullable&lt;string | number | undefined&gt;; // string | number\ntype C1 = NonNullable&lt;string[] | null | undefined&gt;; // string[]</code>\n\n<span>Практический пример</span>\nФункция <code>keys</code>, которая возвращает список ключей объекта. С помощью <i>Extract</i> мы гарантируем, что результат будет <i>массивом строковых ключей</i>.\n<code>export function keys&lt;T extends object&gt;(obj: T): Extract&lt;keyof T, string&gt;[] {\n  const currentKeys: string[] = [];\n  for (let key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      currentKeys.push(key);\n    }\n  }\n  return currentKeys;\n}\n\nconst person = { name: 'Ada', age: 36 };\nconst result = keys(person); // (\"name\" | \"age\")[]</code>"},
    {"id": 29, "header": "Record, Pick, Omit", "content": "TypeScript предоставляет <i>утилитные типы</i>, которые упрощают работу с объектами и выборкой их свойств. Рассмотрим три из них: <code>Record</code>, <code>Pick</code> и <code>Omit</code>.\n\n<span>Record</span>\n<i>Record&lt;Keys, Type&gt;</i> создаёт объектный тип с ключами <code>Keys</code> и значениями типа <code>Type</code>.\n<code>type FruitStock = Record&lt;string, number&gt;;\n\nconst fruits: FruitStock = {\n  apple: 10,\n  banana: 5,\n  mango: 7\n};\n\ntype CarBrands = 'tesla' | 'bmw' | 'audi';\ntype BrandAvailability = Record&lt;CarBrands, boolean&gt;;\n\nconst availableCars: BrandAvailability = {\n  tesla: true,\n  bmw: false,\n  audi: true\n};</code>\n\n<span>Pick</span>\n<i>Pick&lt;Type, Keys&gt;</i> выбирает только указанные свойства из типа.\n<code>type Task = {\n  id: number,\n  title: string,\n  description: string,\n  completed: boolean,\n  createdAt: Date\n};\n\ntype TaskPreview = Pick&lt;Task, 'title' | 'completed'&gt;;\n\nconst preview: TaskPreview = {\n  title: 'Write article',\n  completed: false\n};</code>\n\n<span>Omit</span>\n<i>Omit&lt;Type, Keys&gt;</i> создаёт тип, исключая указанные свойства.\n<code>type TaskWithoutMeta = Omit&lt;Task, 'createdAt' | 'description'&gt;;\n\nconst simpleTask: TaskWithoutMeta = {\n  id: 1,\n  title: 'Refactor code',\n  completed: true\n};</code>\n\n<span>Итоги</span>\n<code>Record</code> полезен для <i>типизации словарей</i>, <code>Pick</code> — когда нужно <i>взять только часть свойств</i>, а <code>Omit</code> — чтобы <i>исключить ненужные поля</i>. Вместе они позволяют гибко управлять структурами объектов."},
    {"id": 30, "header": "Readonly, Partial, Required", "content": "TypeScript предоставляет утилитные типы, которые помогают управлять обязательностью и изменяемостью свойств объектов. Рассмотрим <code>Readonly</code>, <code>Partial</code> и <code>Required</code>.\n\n<span>Readonly</span>\n<i>Readonly&lt;Type&gt;</i> делает все свойства объекта доступными только для чтения. Их нельзя изменить после создания.\n<code>type Book = {\n  id: number,\n  title: string,\n  author: string,\n  published: Date\n};\n\ntype ReadonlyBook = Readonly&lt;Book&gt;;\n\nconst myBook: ReadonlyBook = {\n  id: 1,\n  title: 'TypeScript Deep Dive',\n  author: 'Basarat',\n  published: new Date(2020, 5, 12)\n};\n\n// Ошибка: свойства только для чтения\n// myBook.title = 'Changed Title';</code>\n\n<span>Partial</span>\n<i>Partial&lt;Type&gt;</i> делает все свойства объекта <i>необязательными</i>. Это удобно для обновлений или при создании неполных объектов.\n<code>type User = {\n  id: number,\n  name: string,\n  email: string\n};\n\ntype PartialUser = Partial&lt;User&gt;;\n\nfunction updateUser(user: User, fields: PartialUser) {\n  return { ...user, ...fields };\n}\n\nconst oldUser: User = { id: 1, name: 'Alice', email: 'alice@mail.com' };\nconst updatedUser = updateUser(oldUser, { email: 'new@mail.com' });</code>\n\n<span>Required</span>\n<i>Required&lt;Type&gt;</i> делает все свойства объекта <i>обязательными</i>, даже если раньше они были помечены <code>?</code>.\n<code>type Config = {\n  url?: string,\n  method?: 'GET' | 'POST',\n  timeout?: number\n};\n\ntype StrictConfig = Required&lt;Config&gt;;\n\nconst cfg: StrictConfig = {\n  url: 'https://api.com',\n  method: 'GET',\n  timeout: 5000\n};</code>\n\n<span>Итоги</span>\n<code>Readonly</code> защищает от изменений, <code>Partial</code> позволяет работать с неполными объектами, а <code>Required</code> делает все поля обязательными. Эти утилиты помогают <i>контролировать структуру данных</i> и писать более надёжный код."},
    {"id": 31, "header": "Parameters", "content": "В TypeScript утилитные типы <code>Parameters</code> и <code>ConstructorParameters</code> позволяют извлекать типы аргументов функций и конструкторов. Это полезно для <i>автоматического выведения сигнатур</i> и сокращения дублирования кода.\n\n<span>Parameters</span>\n<i>Parameters&lt;Type&gt;</i> возвращает кортеж типов аргументов функции.\n<code>function joinStrings(a: string, b: string, sep: string) {\n  return a + sep + b;\n}\n\ntype Args = Parameters&lt;typeof joinStrings&gt;;\n// Args = [string, string, string]\n\nfunction runJoin(...args: Args) {\n  return joinStrings(...args);\n}\n\nconst result = runJoin('Hello', 'World', ', ');</code>\n\n<span>ReturnType</span>\nЧасто используется вместе с <code>Parameters</code>, чтобы получить <i>и аргументы, и возвращаемое значение</i>.\n<code>type Return = ReturnType&lt;typeof joinStrings&gt;;\n// Return = string</code>\n\n<span>ConstructorParameters</span>\n<i>ConstructorParameters&lt;Type&gt;</i> возвращает кортеж типов аргументов конструктора класса.\n<code>class User {\n  constructor(public name: string, public age: number) {}\n}\n\ntype UserArgs = ConstructorParameters&lt;typeof User&gt;;\n// UserArgs = [string, number]\n\nconst u = new User(...(['Alice', 30] as UserArgs));</code>\n\n<span>Пример с встроенными конструкторами</span>\nМожно также извлекать аргументы у стандартных классов, например <code>Error</code> или <code>Date</code>.\n<code>type ErrorArgs = ConstructorParameters&lt;ErrorConstructor&gt;;\n// ErrorArgs = [message?: string]\n\nconst err = new Error(...(['Something went wrong'] as ErrorArgs));</code>\n\n<span>Итоги</span>\n<code>Parameters</code> помогает получать типы аргументов функций, а <code>ConstructorParameters</code> — конструкторов. Вместе с <code>ReturnType</code> они позволяют <i>гибко описывать сигнатуры</i> и строить универсальные утилиты."},
    {"id": 32, "header": "Indexed", "content": "Индексированные типы позволяют извлекать типы из структур данных, обращаясь к ним так же, как и в обычном коде. \n\n<span>Пример 1. Доступ к вложенным объектам</span><br/>\n<code>interface PageLayout {\n  id: string,\n  title: string,\n  elements: {\n    header: {\n      title: string,\n      description: string,\n      links: string[]\n    },\n    footer: {\n      description: string,\n      links: string[]\n    }\n  }\n}\n\ntype HeaderType = PageLayout['elements']['header'];\n\nconst headerExample: HeaderType = {\n  title: 'Главная',\n  description: 'Описание блока',\n  links: ['/', '/about']\n}</code><br/>\n\n<span>Пример 2. Работа с кортежами</span><br/>\n<code>type MixedTuple = [number, string, boolean];\n\ntype SecondElement = MixedTuple[1]; // string</code><br/>\n\n<span>Пример 3. Индексация с помощью const-assertion</span><br/>\n<i>При использовании as const массив становится readonly, а его значения можно использовать как объединение литеральных типов.</i><br/>\n<code>const sizes = ['small', 'medium', 'large'] as const;\n\ntype Size = typeof sizes[number];\n\nconst t: Size = 'medium';</code><br/>\n\n<span>Вывод</span><br/> Индексированные типы позволяют <i>динамически извлекать</i> типы из объектов и массивов, делая код более гибким и безопасным."},
    {"id": 33, "header": "Шаблонные литералы", "content": "Шаблонные литералы в TypeScript позволяют создавать новые строковые типы на основе существующих объединений строк и утилитных типов. Это <i>удобный способ</i> динамически формировать строки, применимые, например, в CSS-классах или фабриках функций.<br/><br/>\n\n<span>Пример 1. Формирование CSS-свойств</span><br/>\n<code>type Side = 'top' | 'right' | 'bottom' | 'left';\n\ntype PaddingCSS = `padding-${Side}`;\n\ntype PaddingJS = `padding${'' | Capitalize&lt;Side>}`;\n\nconst cssProp: PaddingCSS = 'padding-top';\nconst jsProp: PaddingJS = 'paddingRight';</code><br/>\n\n<span>Пример 2. Генерация классов анимации</span><br/>\n<code>type Direction = 'up' | 'down' | 'left' | 'right';\ntype State = 'in' | 'out';\n\ntype AnimationClass = `slide${Capitalize&lt;State>}${'' | Capitalize&lt;Direction>}`;\n\nconst anim: AnimationClass = 'slideInLeft';</code><br/>\n\n<span>Пример 3. Маппинг ключей интерфейса</span><br/>\n<i>Шаблонные литералы можно использовать совместно с mapped types для создания \"сетеров\".</i><br/>\n<code>interface User {\n  name: string,\n  age: number,\n  active: boolean\n}\n\ntype UserSetters = {\n  [K in keyof User as `set${Capitalize&lt;K>}`]: (obj: User, value: User[K]) => void\n}\n\nconst setters: UserSetters = {\n  setName: (obj, value) => { obj.name = value },\n  setAge: (obj, value) => { obj.age = value },\n  setActive: (obj, value) => { obj.active = value }\n}</code><br/>\n\n<span>Вывод</span><br/> Шаблонные литералы позволяют <i>гибко комбинировать строковые типы.</i>"},
    {"id": 34, "header": "Классы", "content": "<span>Базовая типизация класса</span><br/><br/>В TypeScript классы позволяют объединить данные и поведение в одном шаблоне. Мы можем определять методы, интерфейсы и создавать экземпляры объектов с конкретной логикой. <i>Интерфейсы</i> помогают задать обязательные методы, которые должен реализовать класс.<br/><br/><code>interface IWeapon {\n  fire(power: number): void,\n  reload(): void\n}\n\nclass Gun implements IWeapon {\n  fire(power: number) {\n    console.log('Weapon fired with power', power);\n  }\n  reload() {\n    console.log('Reloading weapon...');\n  }\n}\n\nconst pistol = new Gun();\npistol.fire(10);\npistol.reload();</code><br/><br/>Класс может быть расширен другим классом. При этом методы родителя доступны потомку.<br/><br/><code>class Machine {\n  public start() {\n    console.log('Machine started');\n  }\n}\n\nclass Tank extends Machine {\n  public move(distance: number) {\n    console.log('Tank moved', distance, 'meters');\n  }\n}\n\nconst t34 = new Tank();\nt34.start();\nt34.move(15);</code><br/><br/>Таким образом, классы создают <i>структурированный способ</i> организации кода, совмещая данные и методы в одном месте."},
    {"id": 35, "header": "Модификаторы доступа", "content": "<span>Модификаторы доступа в Классах</span><br/><br/>В TypeScript у классов есть <i>три уровня доступа</i> — <code>public</code>, <code>protected</code> и <code>private</code>. Они управляют тем, какие свойства и методы доступны за пределами класса.<br/><br/><code>class Creature {\n  public attack(chance: number) {\n    console.log('Chance to attack is', Math.floor(chance));\n  }\n  protected status(info: string) {\n    console.log('Creature info:', info);\n  }\n  private secret(power: number) {\n    console.log('Hidden attack power', power);\n  }\n}\n\nclass Human extends Creature {\n  public boostAttack(value: number) {\n    this.attack(value); // OK\n    this.status('Boosting power...'); // OK\n    // this.secret(value); // Ошибка — private недоступен\n  }\n}\n\nconst human = new Human();\nhuman.attack(5); // OK\n// human.status('Check'); // Ошибка — protected\n// human.secret(10); // Ошибка — private</code><br/><br/><i>Public</i> делает метод доступным везде.<br/><i>Protected</i> — только внутри класса и его наследников.<br/><i>Private</i> — только внутри самого класса.<br/><br/>Такая система повышает <i>инкапсуляцию</i> и предотвращает случайное использование внутренней логики класса."},
    {"id": 36, "header": "Constructor", "content": "Конструктор — это специальный метод, который вызывается при создании экземпляра класса. Он используется для <i>инициализации свойств</i> и подготовки объекта к работе.\n\n<i>Ключевое слово</i> <code>constructor</code> позволяет передавать значения при создании нового объекта. Если класс наследуется от другого, конструктор потомка должен вызвать <code>super()</code> — конструктор родителя.\n\n<code>class Creature  {\n\n  constructor(protected createdAt: Date) {};\n\n  public attack(chance: number) {\n    console.log('Chance to attack is', Math.floor(chance));\n  }\n\n  public move(steps: number) {\n    console.log('Move', steps, 'steps ahead');\n  }\n}\n\nclass Human extends Creature {\n\n  constructor(public readonly hp: number, public skills: string[]) {\n    super(new Date());\n  }\n\n  getInfo() {\n    console.log(this.hp, this.skills, this.createdAt);\n  }\n}\n\nconst vladimir = new Human(100, ['rush']);\nvladimir.skills.push('slash');\n// vladimir.hp = 95; // Ошибка — свойство readonly</code>\n\nВ этом примере класс <code>Human</code> наследуется от <code>Creature</code> и вызывает его конструктор с помощью <code>super()</code>. Благодаря этому свойство <code>createdAt</code> корректно инициализируется в родительском классе.\n\n<i>Readonly-свойства</i> защищают значения от изменения после создания объекта. А параметры конструктора, помеченные модификаторами (<code>public</code>, <code>protected</code>, <code>readonly</code>), автоматически становятся свойствами экземпляра.\n\nТакой подход делает код более <i>чистым</i> и <i>предсказуемым</i>, избавляя от дублирования логики и повышая безопасность структуры класса."},
    {"id": 37, "header": "Абстракции", "content": "<i>Абстрактные классы</i> — это шаблоны для других классов. Они не могут быть созданы напрямую, а лишь задают общую структуру, которую потомки обязаны реализовать. С их помощью можно определить, какие методы и свойства должны существовать у всех наследников.\n\nКлючевое слово <code>abstract</code> используется для обозначения класса или его членов (методов, свойств), которые нужно обязательно реализовать в производных классах.\n\n<code>abstract class Creature {\n  abstract hp: number;\n\n  abstract attack(chance: number): void;\n\n  public defence(chance: number) {\n    console.log('Chance to defence is', Math.floor(chance));\n  }\n}\n\nexport class Human extends Creature {\n  constructor(public hp: number) {\n    super();\n  }\n\n  public attack(chance: number) {\n    console.log('Chance to player attack is', Math.floor(chance));\n  }\n}\n\n// const c = new Creature(); // Ошибка: нельзя создать экземпляр абстрактного класса\n\nconst human = new Human(120);\nhuman.attack(5);\nhuman.defence(8);</code>\n\nВ этом примере <i>Creature</i> определяет базовую структуру для всех существ, задавая обязательные свойства и методы. Класс <i>Human</i> реализует эти элементы, предоставляя собственную реализацию метода <code>attack</code> и конкретное значение <code>hp</code>.\n\nАбстракция помогает создавать <i>гибкую архитектуру</i>: можно описывать поведение, не указывая, как оно должно быть реализовано. Это делает код более расширяемым и снижает связанность между компонентами системы."},
    {"id": 38, "header": "Геттеры и Сеттеры", "content": "<i>Геттеры</i> и <i>сеттеры</i> в TypeScript позволяют контролировать доступ к свойствам объекта. Они помогают инкапсулировать внутренние данные класса, предоставляя возможность управлять их чтением и изменением через методы.\n\nГеттер используется для получения значения, а сеттер — для его изменения. Это позволяет выполнять дополнительные проверки или вычисления при обращении к свойству.\n\n<code>export class Creature {\n  constructor(public attack: number, private _critChance: number) {}\n\n  get critChance(): number {\n    return this._critChance;\n  }\n\n  set critChance(crit: number) {\n    if (crit > 0) {\n      this._critChance = Math.floor(crit);\n    }\n  }\n}\n\nconst wolf = new Creature(15, 3);\nwolf.critChance = 5;\nconsole.log(wolf.critChance);</code>\n\nВ этом примере свойство <code>_critChance</code> скрыто от внешнего доступа благодаря модификатору <i>private</i>. Доступ к нему возможен только через <code>get</code> и <code>set</code> методы. Сеттер дополнительно проверяет, что переданное значение положительное, а затем округляет его вниз.\n\nТаким образом, использование геттеров и сеттеров обеспечивает <i>контроль над состоянием объекта</i> и помогает избежать непреднамеренных ошибок при изменении данных."}
  ],
  "react": [{"id": 1, "header": "Что это", "content": "<i>React</i> — это JavaScript-библиотека для разработки пользовательского интерфейса."}],
  "exercises": [{"id": 1, "header": "Array.diff", "content": "Реализуйте функцию, которая вычисляет разницу между двумя списками. Функция должна удалить все вхождения элементов из первого списка (a), которые присутствуют во втором списке (b). Порядок элементов в первом списке должен быть сохранен в результате.\n\nПримеры:\n\nЕсли a = [1, 2] и b = [1], результат должен быть [2].\n\nЕсли a = [1, 2, 2, 2, 3] и b = [2], результат должен быть [1, 3]."},
  {"id": 2, "header": "Нарциссическое число (или число Армстронга)", "content": "Нарциссическое число (или число Армстронга) — это положительное число, которое равно сумме своих цифр, возведённых в степень, равную количеству цифр в данном основании. В данной задаче мы ограничимся десятичной системой (основание 10).\n\nНапример, возьмём число 153 (3 цифры), которое является нарциссическим:\n\n    1^3 + 5^3 + 3^3 = 1 + 125 + 27 = 153\n\nи число 1652 (4 цифры), которое не является:\n\n    1^4 + 6^4 + 5^4 + 2^4 = 1 + 1296 + 625 + 16 = 1938\n\nЗадача:\n\nВаш код должен возвращать true или false (не строки 'true' и 'false') в зависимости от того, является ли заданное число нарциссическим числом в base 10.\n\nВ вашем языке это может быть True и False, например, в PHP.\n\nПроверка на текстовые строки или другие недопустимые входные данные не требуется, в функцию будут передаваться только допустимые положительные ненулевые целые числа."},
  {"id": 3, "header": "Подсчёт гласных", "content": "Верните количество гласных в заданной строке.\n\nМы будем рассматривать a, e, i, o, u как гласные для этой задачи (но не y).\n\nВходная строка будет состоять только из строчных букв и/или пробелов."}]
}